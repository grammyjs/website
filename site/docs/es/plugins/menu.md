---
prev: false
next: false
---

# Men√∫s interactivos (`menu`)

Crea f√°cilmente men√∫s interactivos.

## Introducci√≥n

Un teclado en l√≠nea es un conjunto de botones debajo de un mensaje.
grammY tiene un [plugin incorporado](./keyboard#teclados-en-linea) para crear teclados en l√≠nea b√°sicos.

El plugin de men√∫s lleva esta idea m√°s all√° y te permite crear men√∫s ricos justo dentro del chat.
Pueden tener botones interactivos, m√∫ltiples p√°ginas con navegaci√≥n entre ellas, y m√°s.

Aqu√≠ hay un ejemplo simple que habla por s√≠ mismo.

::: code-group

```ts [TypeScript]
import { Bot } from "grammy";
import { Menu } from "@grammyjs/menu";

// Crea un bot.
const bot = new Bot("");

// Cree un men√∫ sencillo.
const menu = new Menu("mi-identificador-de-menu")
  .text("A", (ctx) => ctx.reply("¬°Has pulsado A!")).row()
  .text("B", (ctx) => ctx.reply("¬°Has pulsado B!"));

// Hazlo interactivo.
bot.use(menu);

bot.command("start", async (ctx) => {
  // Env√≠a el men√∫.
  await ctx.reply("Mira este men√∫:", { reply_markup: menu });
});

bot.start();
```

```js [JavaScript]
const { Bot } = require("grammy");
const { Menu } = require("@grammyjs/menu");

// Crea un bot.
const bot = new Bot("");

// Cree un men√∫ sencillo.
const menu = new Menu("mi-identificador-de-menu")
  .text("A", (ctx) => ctx.reply("¬°Has pulsado A!")).row()
  .text("B", (ctx) => ctx.reply("¬°Has pulsado B!"));

// Hazlo interactivo.
bot.use(menu);

bot.command("start", async (ctx) => {
  // Env√≠a el men√∫.
  await ctx.reply("Mira este men√∫:", { reply_markup: menu });
});

bot.start();
```

```ts [Deno]
import { Bot } from "https://deno.land/x/grammy/mod.ts";
import { Menu } from "https://deno.land/x/grammy_menu/mod.ts";

// Crea un bot.
const bot = new Bot("");

// Cree un men√∫ sencillo.
const menu = new Menu("mi-identificador-de-menu")
  .text("A", (ctx) => ctx.reply("¬°Has pulsado A!")).row()
  .text("B", (ctx) => ctx.reply("¬°Has pulsado B!"));

// Hazlo interactivo.
bot.use(menu);

bot.command("start", async (ctx) => {
  // Env√≠a el men√∫.
  await ctx.reply("Mira este men√∫:", { reply_markup: menu });
});

bot.start();
```

:::

> Aseg√∫rese de instalar todos los men√∫s antes de otros middleware, especialmente antes de los middleware que utilizan datos de consulta de devoluci√≥n de llamada.

Naturalmente, si est√° utilizando un [tipo de contexto personalizado](../guide/context#personalizacion-del-objeto-de-contexto), puede pasarlo a `Menu` tambi√©n.

```ts
const menu = new Menu<MyContext>("id");
```

## Adding Buttons

El plugin de men√∫s presenta sus teclados exactamente como lo hace el [plugin para teclados en l√≠nea] (./keyboard#building-an-inline-keyboard).
La clase `Menu` reemplaza a la clase `InlineKeyboard`.

Aqu√≠ hay un ejemplo para un men√∫ que tiene cuatro botones en forma de fila 1-2-1.

```ts
const menu = new Menu("movimientos")
  .text("^", (ctx) => ctx.reply("¬°Adelante!")).row()
  .text("<", (ctx) => ctx.reply("¬°Izquierda!"))
  .text(">", (ctx) => ctx.reply("¬°Derecha!")).row()
  .text("v", (ctx) => ctx.reply("¬°Atr√°s!"));
```

Utilice `text` para a√±adir nuevos botones de texto.
Puede pasar una etiqueta y una funci√≥n manejadora.

Utilice `row` para terminar la fila actual, y a√±adir todos los botones posteriores a una nueva fila.

Hay muchos m√°s tipos de botones disponibles, por ejemplo, para abrir URLs.
Echa un vistazo a la [Referencia API de este plugin](/ref/menu/menurange) para `MenuRange`, as√≠ como a la [Referencia API de Telegram Bot](https://core.telegram.org/bots/api#inlinekeyboardbutton) para `InlineKeyboardButton`.

## Enviando un Men√∫

Primero debes instalar un men√∫.
Esto lo hace interactivo.

```ts
bot.use(menu);
```

Ahora puede pasar simplemente el men√∫ como `reply_markup` al enviar un mensaje.

```ts
bot.command("menu", async (ctx) => {
  await ctx.reply("Este es su men√∫", { reply_markup: menu });
});
```

## Etiquetas din√°micas

Siempre que pongas una cadena de etiqueta en un bot√≥n, tambi√©n puedes pasar una funci√≥n `(ctx: Context) => string` para obtener una etiqueta din√°mica en el bot√≥n.
Esta funci√≥n puede ser o no `async`.

```ts
// Cree un bot√≥n con el nombre del usuario, que le dar√° la bienvenida cuando lo pulse.
const menu = new Menu("saludame")
  .text(
    (ctx) => `Saluda ${ctx.from?.first_name ?? "me"}!`, // etiqueta din√°mica
    (ctx) => ctx.reply(`Hola ${ctx.from.first_name}!`), // manejador
  );
```

Una cadena generada por una funci√≥n de este tipo se denomina _cadena din√°mica_.
Las cadenas din√°micas son ideales para cosas como los botones de alternancia.

```ts
// Conjunto de identificadores de usuario que tienen activadas las notificaciones.
const notifications = new Set<number>();

function toggleNotifications(id: number) {
  if (!notifications.delete(id)) notifications.add(id);
}

const menu = new Menu("toggle")
  .text(
    (ctx) => ctx.from && notifications.has(ctx.from.id) ? "üîî" : "üîï",
    (ctx) => {
      toggleNotifications(ctx.from.id);
      ctx.menu.update(); // ¬°actualizar el men√∫!
    },
  );
```

Tenga en cuenta que debe actualizar un men√∫ siempre que quiera que sus botones cambien.
Llama a `ctx.menu.update()` para asegurarte de que tu men√∫ se volver√° a renderizar.

::: tip Almacenamiento de datos
El ejemplo anterior demuestra c√≥mo utilizar el plugin de men√∫.
No es una buena idea almacenar la configuraci√≥n del usuario en un objeto `Set`, porque entonces todos los datos se perder√°n cuando se detenga el servidor.

En su lugar, considere el uso de una base de datos o el [plugin de sesi√≥n] (./session) si desea almacenar datos.
:::

## Actualizar o cerrar el men√∫

Cuando se llama a un manejador de bot√≥n, un n√∫mero de funciones √∫tiles est√°n disponibles en `ctx.menu`.

Si quieres que tu men√∫ se vuelva a renderizar, puedes llamar a `ctx.menu.update()`.
Esto s√≥lo funcionar√° dentro de los manejadores que instales en tu men√∫.
No funcionar√° cuando se llame desde otro bot middleware, ya que en estos casos no hay forma de saber _qu√©_ men√∫ debe ser actualizado.

```ts
const menu = new Menu("time", { onMenuOutdated: false })
  .text(
    () => new Date().toLocaleString(), // la etiqueta del bot√≥n es la hora actual
    (ctx) => ctx.menu.update(), // actualiza la hora al pulsar el bot√≥n
  );
```

> El prop√≥sito de `onMenuOutdated` se explica [m√°s abajo](#menus-y-huellas-anticuadas).
> Puedes ignorarlo por ahora.

Tambi√©n puede actualizar el men√∫ impl√≠citamente editando el mensaje correspondiente.

```ts
const menu = new Menu("time")
  .text(
    "¬øQu√© hora es?",
    (ctx) => ctx.editMessageText("Son las " + new Date().toLocaleString()),
  );
```

El men√∫ detectar√° que usted tiene la intenci√≥n de editar el texto del mensaje, y aprovechar√° la oportunidad para actualizar tambi√©n los botones que se encuentran debajo.
Como resultado, a menudo puede evitar tener que llamar a `ctx.menu.update()` expl√≠citamente.

Llamar a `ctx.menu.update()` no actualiza el men√∫ inmediatamente.
En su lugar, establece una bandera y recuerda actualizarlo en alg√∫n momento durante la ejecuci√≥n de tu middleware.
Esto se llama _actualizaci√≥n lenta_.
Si editas el mensaje en s√≠ m√°s tarde, el plugin puede simplemente usar la misma llamada a la API para actualizar tambi√©n los botones.
Esto es muy eficiente, y asegura que tanto el mensaje como el teclado se actualicen al mismo tiempo.

Naturalmente, si llamas a `ctx.menu.update()` pero nunca solicitas ninguna edici√≥n del mensaje, el plugin del men√∫ actualizar√° el teclado por s√≠ mismo, antes de que tu middleware se complete.

Puedes forzar que el men√∫ se actualice inmediatamente con `await ctx.menu.update({ immediate: true })`.
Ten en cuenta que `ctx.menu.update()` devolver√° una promesa, por lo que debes usar `await`.
El uso de la bandera `inmediata` tambi√©n funciona para todas las dem√°s operaciones que puedes llamar en `ctx.menu`.
Esto s√≥lo deber√≠a usarse cuando sea necesario.

Si quieres cerrar un men√∫, es decir, eliminar todos los botones, puedes llamar a `ctx.menu.close()`.
De nuevo, esto se realizar√° de forma perezosa.

## Navegaci√≥n entre men√∫s

Se pueden crear f√°cilmente men√∫s con varias p√°ginas, y navegar entre ellas.
Cada p√°gina tiene su propia instancia de `Men√∫`.
El bot√≥n `submen√∫` es un bot√≥n que le permite navegar a otras p√°ginas.
La navegaci√≥n hacia atr√°s se hace a trav√©s del bot√≥n `back`.

```ts
const main = new Menu("root-menu")
  .text("Bienvenido", (ctx) => ctx.reply("¬°Hola!")).row()
  .submenu("Cr√©ditos", "credits-menu");

const settings = new Menu("credits-menu")
  .text("Mostrar cr√©ditos", (ctx) => ctx.reply("Desarrollado por grammY"))
  .back("Volver");
```

Ambos botones toman opcionalmente manejadores de middleware para que puedas reaccionar a los eventos de navegaci√≥n.

En lugar de utilizar los botones `submenu` y `back` para navegar entre p√°ginas, tambi√©n puedes hacerlo manualmente utilizando `ctx.menu.nav()`.
Esta funci√≥n toma la cadena del identificador del men√∫, y realizar√° la navegaci√≥n de forma perezosa.
An√°logamente, la navegaci√≥n hacia atr√°s funciona a trav√©s de `ctx.menu.back()`.

A continuaci√≥n, hay que enlazar los men√∫s registr√°ndolos entre s√≠.
Registrar un men√∫ a otro implica su jerarqu√≠a. El men√∫ al que se est√° registrando es el padre, y el men√∫ registrado es el hijo.
A continuaci√≥n, `main` es el padre de `settings`, a menos que se defina expl√≠citamente un padre diferente.
El men√∫ padre se utiliza cuando se realiza una navegaci√≥n hacia atr√°s.

```ts
// Registrar el men√∫ de ajustes en el men√∫ principal.
main.register(settings);
// Opcionalmente, establece un padre diferente.
main.register(settings, "back-from-settings-menu");
```

Puedes registrar tantos men√∫s como quieras, y anidarlos tan profundamente como quieras.
Los identificadores de men√∫ le permiten saltar f√°cilmente a cualquier p√°gina.

**S√≥lo tienes que hacer interactivo un √∫nico men√∫ de tu estructura de men√∫s anidados.**
Por ejemplo, s√≥lo pasa el men√∫ ra√≠z a `bot.use`.

```ts
// Si tienes esto:
main.register(settings);

// Haz esto:
bot.use(main);

// No hagas esto:
bot.use(main);
bot.use(settings);
```

**Puedes crear varios men√∫s independientes y hacerlos todos interactivos.**
Por ejemplo, si creas dos men√∫s no relacionados entre s√≠ y nunca necesitas navegar entre ellos, entonces debes instalar ambos de forma independiente.

```ts
// Si tienes men√∫s independientes como este
const menuA = new Menu("menu-a");
const menuB = new Menu("menu-b");

// Puedes hacer esto
bot.use(menuA);
bot.use(menuB);
```

## Payloads

Puede almacenar cargas √∫tiles de texto cortas junto con todos los botones de navegaci√≥n y de texto.
Cuando los respectivos manejadores son invocados, la carga √∫til de texto estar√° disponible bajo `ctx.match`.
Esto es √∫til porque le permite almacenar un poco de informaci√≥n en un men√∫.

Este es un ejemplo de men√∫ que recuerda la hora actual en el payload.
Otros casos de uso podr√≠an ser, por ejemplo, almacenar el √≠ndice en un men√∫ paginado.

```ts
function generatePayload() {
  return Date.now().toString();
}

const menu = new Menu("store-current-time-in-payload")
  .text(
    { text: "¬°ABORTAR!", payload: generatePayload },
    async (ctx) => {
      // Dar al usuario 5 segundos para deshacer.
      const text = Date.now() - Number(ctx.match) < 5000
        ? "La operaci√≥n se ha cancelado con √©xito."
        : "Demasiado tarde. Tus v√≠deos de gatos ya se han hecho virales en Internet.";
      await ctx.reply(text);
    },
  );

bot.use(menu);
bot.command("publish", async (ctx) => {
  await ctx.reply(
    "Los v√≠deos se enviar√°n. Tienes 5 segundos para cancelarlo.",
    {
      reply_markup: menu,
    },
  );
});
```

::: tip Limitaciones
Las cargas √∫tiles no pueden utilizarse para almacenar cantidades significativas de datos.
Lo √∫nico que puede almacenar son cadenas cortas de t√≠picamente menos de 50 bytes, como un √≠ndice o un identificador.
Si realmente quieres almacenar datos de usuario como un identificador de fichero, una URL, o cualquier otra cosa, deber√≠as usar [sessions](./session).

Adem√°s, tenga en cuenta que la carga √∫til siempre se genera bas√°ndose en el objeto de contexto actual.
Esto significa que importa _desde_ d√≥nde se navega al men√∫, lo que puede dar lugar a resultados sorprendentes.
Por ejemplo, cuando un men√∫ est√° [desactualizado](#menus-y-huellas-anticuadas), se volver√° a renderizar _bas√°ndose en el clic del bot√≥n del men√∫ desactualizado_.
:::

Payloads tambi√©n funcionan bien junto con los rangos din√°micos.

## Rangos din√°micos

Hasta ahora, s√≥lo hemos visto c√≥mo cambiar el texto de un bot√≥n de forma din√°mica.
Tambi√©n se puede ajustar din√°micamente la estructura de un men√∫ para a√±adir y eliminar botones sobre la marcha.

::: peligro Cambiar un men√∫ durante el manejo de mensajes
No se pueden crear o modificar los men√∫s durante la gesti√≥n de los mensajes.
Todos los men√∫s deben estar completamente creados y registrados antes de que se inicie tu bot.
Esto significa que no puedes hacer `new Menu("id")` en un manejador de tu bot.

A√±adir nuevos men√∫s mientras tu bot se est√° ejecutando causar√≠a una fuga de memoria.
Tu bot se ralentizar√≠a cada vez m√°s, y finalmente se colgar√≠a.

Sin embargo, puedes hacer uso de los rangos din√°micos descritos en esta secci√≥n.
Te permiten cambiar arbitrariamente la estructura de una instancia de men√∫ existente, por lo que son igualmente potentes.
¬°Utilice rangos din√°micos!
:::

Puede dejar que una parte de los botones de un men√∫ se genere sobre la marcha (o todos ellos si lo desea).
A esta parte del men√∫ la llamamos _rango din√°mico_.
La forma m√°s sencilla de crear un rango din√°mico es utilizando la clase `MenuRange` que proporciona este plugin.
Un `MenuRange` le proporciona exactamente las mismas funciones que un men√∫, pero no tiene un identificador, y no puede ser registrado.

```ts
function getRandomInt(minInclusive: number, maxExclusive: number) {
  const range = maxExclusive - minInclusive;
  return minInclusive + Math.floor(range * Math.random());
}

// Crea un men√∫ con un n√∫mero aleatorio de botones.
const menu = new Menu("random", { onMenuOutdated: false });

menu
  .text("Regenerar", (ctx) => ctx.menu.update())
  .row();
menu.dynamic(() => {
  const range = new MenuRange();
  const buttonCount = getRandomInt(2, 9); // 2-8 botones
  for (let i = 0; i < buttonCount; i++) {
    range
      .text(i.toString(), (ctx) => ctx.reply(`${i} seleccionado`))
      .row();
  }
  return range;
});
```

La funci√≥n de generaci√≥n de rangos que se pasa a `dynamic` puede ser `async`, por lo que incluso se pueden realizar llamadas a la API o hacer comunicaci√≥n con la base de datos antes de devolver el nuevo rango del men√∫.
**En muchos casos, tiene sentido generar un rango din√°mico basado en los datos de [session](./session).**

Adem√°s, la funci√≥n de construcci√≥n de rangos toma un objeto de contexto como primer argumento.
(Esto no se especifica en el ejemplo anterior).
Opcionalmente, como segundo argumento despu√©s de `ctx`, puede recibir una instancia fresca de `MenuRange`.
Puedes modificarlo en lugar de devolver tu propia instancia si es lo que prefieres.
As√≠ es como puedes utilizar los dos par√°metros de la funci√≥n constructora de rangos.

```ts
menu.dynamic((ctx, range) => {
  for (const text of ctx.session.items) {
    range // no se necesita `new MenuRange()` o un `return`.
      .text(text, (ctx) => ctx.reply(text))
      .row();
  }
});
```

## Responder manualmente a las consultas de devoluci√≥n de llamada

El plugin del men√∫ llamar√° a `answerCallbackQuery` autom√°ticamente para sus propios botones.
Puede establecer `autoAnswer: false` si quiere desactivar esto.

```ts
const menu = new Menu("id", { autoAnswer: false });
```

Ahora tendr√° que llamar usted mismo a `answerCallbackQuery`.
Esto le permite pasar mensajes personalizados que se muestran al usuario.

## Men√∫s y Huellas Anticuadas

Digamos que tienes un men√∫ donde un usuario puede activar y desactivar las notificaciones, como en el ejemplo [aqu√≠ arriba](#etiquetas-dinamicas).
Ahora, si un usuario env√≠a `/settings` dos veces, obtendr√° el mismo men√∫ dos veces.
Pero, ¬°cambiar la configuraci√≥n de la notificaci√≥n en uno de los dos mensajes no actualizar√° el otro!

Est√° claro que no podemos hacer un seguimiento de todos los mensajes de configuraci√≥n en un chat, y actualizar todos los men√∫s antiguos en todo el historial del chat.
Tendr√≠as que usar tantas llamadas a la API para esto que Telegram limitar√≠a la velocidad de tu bot.
Tambi√©n necesitar√≠as mucho almacenamiento para recordar todos los identificadores de los mensajes de cada men√∫, en todos los chats.
Esto no es pr√°ctico.

La soluci√≥n, es comprobar si un men√∫ est√° desactualizado _antes_ de realizar cualquier acci√≥n.
De esta manera, s√≥lo actualizaremos los men√∫s antiguos si un usuario empieza a hacer clic en los botones de los mismos.
El plugin de men√∫s maneja esto autom√°ticamente por ti, as√≠ que no tienes que preocuparte por ello.

Puedes configurar exactamente lo que ocurre cuando se detecta un men√∫ obsoleto.
Por defecto, se mostrar√° al usuario el mensaje "El men√∫ estaba obsoleto, int√©ntelo de nuevo" y se actualizar√° el men√∫.
Puede definir un comportamiento personalizado en la configuraci√≥n bajo `onMenuOutdated`.

```ts
// Mensaje personalizado a mostrar
const menu0 = new Menu("id", { onMenuOutdated: "Updated, try now." });
// Funci√≥n de gesti√≥n personalizada
const menu1 = new Menu("id", {
  onMenuOutdated: async (ctx) => {
    await ctx.answerCallbackQuery();
    await ctx.reply("Here is a fresh menu", { reply_markup: menu1 });
  },
});
// Desactivar por completo la comprobaci√≥n de la caducidad (puede ejecutar manejadores de bot√≥n err√≥neos).
const menu2 = new Menu("id", { onMenuOutdated: false });
```

Disponemos de una heur√≠stica para comprobar si el men√∫ est√° anticuado.
Lo consideramos obsoleto si

- La forma del men√∫ ha cambiado (n√∫mero de filas, o n√∫mero de botones en cualquier fila).
- La posici√≥n de la fila/columna del bot√≥n pulsado est√° fuera de rango.
- La etiqueta del bot√≥n pulsado ha cambiado.
- El bot√≥n pulsado no contiene un manejador.

Es posible que su men√∫ cambie, mientras todas las cosas anteriores permanecen igual.
Tambi√©n es posible que su men√∫ no cambie fundamentalmente (es decir, que el comportamiento de los manejadores no cambie), aunque la heur√≠stica anterior indique que el men√∫ est√° desactualizado.
Ambos escenarios son poco probables para la mayor√≠a de los bots, pero si est√°s creando un men√∫ en el que este es el caso, deber√≠as usar una funci√≥n de huella digital.

```ts
function ident(ctx: Context): string {
  // Devuelve una cadena que cambiar√≠a si y s√≥lo si su men√∫ cambia
  // de forma tan significativa que deber√≠a considerarse obsoleto.
  return ctx.session.myStateIdentifier;
}
const menu = new Menu("id", { fingerprint: (ctx) => ident(ctx) });
```

La cadena de huellas digitales sustituir√° a la heur√≠stica anterior.
De este modo, puede estar seguro de que siempre se detectan los men√∫s obsoletos.

## C√≥mo funciona

El plugin de men√∫s funciona completamente sin almacenar ning√∫n dato.
Esto es importante para grandes bots con millones de usuarios.
Guardar el estado de todos los men√∫s consumir√≠a demasiada memoria.

Cuando creas tus objetos de men√∫ y los enlazas a trav√©s de las llamadas `register`, no se construye ning√∫n men√∫.
En su lugar, el plugin de men√∫s recordar√° c√≥mo montar nuevos men√∫s bas√°ndose en sus operaciones.
Cada vez que se env√≠e un men√∫, reproducir√° estas operaciones para renderizar su men√∫.
Esto incluye la disposici√≥n de todos los rangos din√°micos y la generaci√≥n de todas las etiquetas din√°micas.
Una vez enviado el men√∫, la matriz de botones renderizada se olvidar√° de nuevo.

Cuando se env√≠a un men√∫, cada bot√≥n contiene una consulta de devoluci√≥n de llamada que almacena

- El identificador del men√∫.
- La posici√≥n de la fila/columna del bot√≥n.
- Una carga √∫til opcional.
- Una bandera de huella digital que almacena si se ha utilizado o no una huella digital en el men√∫.
- Un hash de 4 bytes que codifica la huella digital o el dise√±o del men√∫ y la etiqueta del bot√≥n.

De esta forma, podemos identificar exactamente qu√© bot√≥n de qu√© men√∫ se ha pulsado.
Un men√∫ s√≥lo manejar√° las pulsaciones de los botones si:

- Los identificadores del men√∫ coinciden.
- Se especifica la fila/columna.
- La bandera de la huella digital existe.

Cuando un usuario pulsa un bot√≥n de un men√∫, necesitamos encontrar el manejador que se a√±adi√≥ a ese bot√≥n en el momento en que se renderiz√≥ el men√∫.
Por lo tanto, simplemente renderizamos el viejo men√∫ de nuevo.
Sin embargo, esta vez, no necesitamos el dise√±o completo---todo lo que necesitamos es la estructura general, y ese bot√≥n espec√≠fico.
En consecuencia, el plugin del men√∫ realizar√° una representaci√≥n superficial para ser m√°s eficiente.
En otras palabras, el men√∫ s√≥lo se renderizar√° parcialmente.

Una vez que se conoce el bot√≥n pulsado de nuevo (y hemos comprobado que el men√∫ no est√° [desactualizado](#menus-y-huellas-anticuadas)), invocamos el manejador.

Internamente, el plugin de men√∫s hace un gran uso de [API Transformer Functions](../advanced/transformers), por ejemplo, para renderizar r√°pidamente los men√∫s salientes sobre la marcha.

Cuando se registran los men√∫s en una gran jerarqu√≠a de navegaci√≥n, de hecho no almacenan estas referencias expl√≠citamente.
Bajo el cap√≥, todos los men√∫s de esa estructura se a√±aden al mismo pool grande, y ese pool se comparte entre todas las instancias contenidas.
Cada men√∫ es responsable de todos los dem√°s en el √≠ndice, y pueden manejarse y renderizarse mutuamente.
(La mayor√≠a de las veces, es s√≥lo el men√∫ ra√≠z el que se pasa a `bot.use` y el que recibe las actualizaciones.
En tales casos, esta instancia manejar√° el conjunto completo).
Como resultado, puedes navegar entre men√∫s arbitrarios sin l√≠mite, todo mientras el manejo de las actualizaciones puede ocurrir en [`O(1)` complejidad de tiempo](https://en.wikipedia.org/wiki/Time_complexity#Constant_time) porque no hay necesidad de buscar a trav√©s de jerarqu√≠as enteras para encontrar el men√∫ correcto para manejar cualquier clic de bot√≥n dado.

## Resumen del plugin

- Nombre: `menu`
- [Fuente](https://github.com/grammyjs/menu)
- [Referencia](/ref/menu/)
