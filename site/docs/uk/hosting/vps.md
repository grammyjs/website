---
prev: false
next: false
---

<!-- markdownlint-disable no-duplicate-heading -->

# Хостинг: VPS

Віртуальний приватний сервер, відомий переважно як VPS, є віртуальною машиною, яка працює в хмарі, а ви, розробник, маєте повний контроль над системою.

## Оренда сервера

> Перш ніж розпочати ознайомлення з посібником, вам потрібно орендувати VPS.
> У цьому розділі пояснюється, як це зробити.
> Якщо у вас вже є VPS для роботи, перейдіть до [наступного розділу](#запуск-бота).

У цьому посібнику ми користуватимемося послугами [Hostinger](https://hostinger.com.ua).

> Ви можете обрати іншого провайдера на свій розсуд.
> Усі провайдери надають однакові послуги, тому у вас не виникне жодних проблем з технічною частиною цієї статті.
> Ви можете розглядати цю частину як огляд того, як відбувається оренда сервера.
> Якщо ви новачок, ви можете скористатися цим посібником, щоб орендувати свій перший сервер!

::: tip Аналог сервера
Якщо ви не можете або не хочете орендувати сервер, але все одно хочете спробувати запустити бота на VPS, ви можете відтворити цей посібник на віртуальній машині.
Для цього скористайтеся застосунком на кшталт [VirtualBox](https://virtualbox.org).
Створіть віртуальну машину з потрібним дистрибутивом Linux для імітації сервера Linux.
:::

Перейдіть на сторінку [хостингу VPS](https://hostinger.com/vps-hosting).
Ми скористаємося тарифом "KVM 1".
Ресурсів "KVM 1" достатньо для ботів з великою аудиторією, а для нашого тестового бота тим паче.

Натисніть кнопку "Додати".
Вас буде автоматично перенаправлено на сторінку оформлення замовлення, де ви одразу зареєструєтесь у Hostinger.

:::warning Змініть строк оренди!
Типовий строк оренди --- 1-2 роки (маркетингова хитрість), і коштує це величезних грошей.
Вам цього, напевно, не треба, тому для початку орендуйте сервер на місяць, що коштує значно дешевше.

У будь-якому випадку, Hostinger надає 30-денну гарантію повернення коштів.
:::

Після оплати ви зможете налаштувати свій сервер:

1. **Місцезнаходження.**
   Ми рекомендуємо вам [вибрати розташування](../guide/api#вибір-місця-розташування-дата-центру) найближче до Амстердама.
   Саме в Амстердамі знаходиться головний сервер Bot API.
   Якщо ви використовуєте [власний сервер Bot API](../guide/api#запуск-локального-сервера-bot-api), виберіть найближче до нього розташування.
2. **Тип сервера.**
   Оберіть варіант "Чиста ОС".
3. **Операційна система.**
   Ми скористаємося Ubuntu 22.04.
   Якщо ви обрали іншу систему, деякі кроки можуть відрізнятися, тому будьте пильними.
4. **Назва сервера.**
   Виберіть будь-яку назву, яка вам подобається.
5. **Root-пароль.**
   Придумайте надійний пароль та зберігайте його у безпечному місці!
6. **SSH-ключ.**
   Пропустіть цей крок.
   Налаштування SSH-ключів ми зробимо [пізніше](#ssh-ключі).

Після створення сервера ви зможете підключитися до нього за допомогою SSH:

> SSH (_Secure Shell_ --- _безпечна оболонка_) - це мережевий протокол, який можна використовувати для віддаленого керування компʼютером.

```sh
ssh root@<ip-адреса>
```

Замініть `<ip-адреса>` на IP-адресу вашого сервера, яку ви можете знайти на сторінці керування сервером.

::: tip Налаштування SSH
Запамʼятовування IP-адреси та імені користувача для підключення до сервера може бути складним і виснажливим.
Щоб позбутися цих рутинних дій і покращити досвід роботи з сервером, ви можете налаштувати SSH, створивши на своєму комп'ютері файл `~/.ssh/config` (<https://linuxhandbook.com/ssh-config-file>), який зберігає всі дані, необхідні для підключення до сервера, під певними довільними ідентифікаторами.
Це виходить за межі цієї статті, тому вам доведеться налаштувати його самостійно.
:::

::: tip Окремий користувач для кожної програми
У цьому посібнику всі дії з сервером будуть виконуватися від імені користувача root (далі "суперкористувач").
Це зроблено навмисно для спрощення посібника.
Однак, насправді, суперкористувач повинен відповідати лише за загальні сервіси (веб-сервер, база даних тощо), а додатки повинні запускатися окремими користувачами, які не є суперкористувачами.
Цей підхід забезпечує захист конфіденційності даних і запобігає можливому доступу до всієї системи хакеру.
У той же час, він накладає певні незручності.
Опис всіх цих моментів невиправдано збільшує складність посібника, чого ми намагаємося уникнути.
:::

## Запуск бота

Тепер у нашому розпорядженні є сервер, на якому ми можемо запустити бота, щоб він працював цілодобово.

Щоб спростити початок статті, ми пропустили крок автоматичної доставки коду на сервер кожного разу після публікації вашого коду, але він описаний [нижче](#ci-cd).

Наразі ви можете скопіювати локальні файли на віддалений сервер за допомогою наступної команди.
Зверніть увагу, що `-r` копіює рекурсивно, тому вам потрібно вказати лише кореневий каталог вашого проекту:

```sh
scp <шлях-до-локального-кореня-проєкту> root@<ip-адреса>:<шлях-до-віддаленого-каталогу>
```

Замініть `<шлях-до-локального-кореня-проєкту>` на шлях до каталогу проєкту на локальному диску, `<ip-адреса>` на IP-адресу вашого сервера, а `<шлях-до-віддаленого-каталогу>` на шлях до каталогу, в якому має зберігатися вихідний код бота на сервері.

Як згадувалося вище, зараз ви можете відкрити віддалений термінал на вашому VPS, запустивши сеанс SSH.

```sh
ssh root@<ip-адреса>
```

Зверніть увагу, як змінився ваш командний рядок.
Це означає, що ви підключені до віддаленого сервера.
Кожна введена вами команда буде виконана на вашому VPS.
Спробуйте виконати `ls`, щоб переконатися, що ви успішно скопіювали вихідні файли.

Далі на цій сторінці передбачається, що ви можете підключитися до вашого VPS.
Всі наступні команди потрібно виконувати в сеансі SSH.

:::tip Не забудьте встановити середовище виконання!
Для запуску бота на сервері потрібно встановити Node.js або Deno, залежно від того, в якому середовищі виконання працюватиме бот.
Це виходить за межі цього посібника, тому вам доведеться зробити це самостійно.
Ймовірно, ви вже робили це під час [початку роботи](../guide/getting-started), тому ви повинні бути знайомі з кроками. :wink:
:::

Нижче наведено два способи забезпечення безперервної роботи бота: за допомогою [systemd](#systemd) або [PM2](#pm2).

### systemd

systemd --- це потужний менеджер служб, який передвстановлений у багатьох дистрибутивах Linux, переважно на основі Debian, як-от Ubuntu.

#### Отримання команди запуску

1. Отримайте абсолютний шлях до вашого середовища виконання:

   ::: code-group

   ```sh [Deno]
   which deno
   ```

   ```sh [Node.js]
   which node
   ```

   :::

2. Ви також повинні мати абсолютний шлях до каталогу вашого бота.

3. Ваша команда запуску повинна виглядати наступним чином:

   ```sh
   <шлях-до-середовища-виконання> <опції> <відносний-шлях-до-вхідного-файлу>

   # Шлях до каталогу бота: /home/user/bot1/

   # Приклад для Deno:
   # /home/user/.deno/bin/deno --allow-all run mod.ts

   # Приклад для Node.js:
   # /home/user/.nvm/versions/node/v16.9.1/bin/node index.js
   ```

#### Створення служби

1. Перейдіть до каталогу служб:

   ```sh
   cd /etc/systemd/system
   ```

2. Відкрийте ваш новий файл служби за допомогою редактора:

   ```sh
   nano <назва-застосунку>.service
   ```

   > Замініть `<назва-застосунку>` будь-яким ідентифікатором.
   > `<назва-застосунку>.service` буде назвою вашого сервісу.

3. Додайте наступний вміст:

   ```text
   [Unit]
   After=network.target

   [Service]
   WorkingDirectory=<шлях-до-каталогу-бота>
   ExecStart=<команда-запуску>
   Restart=on-failure

   [Install]
   WantedBy=multi-user.target
   ```

   Замініть `<шлях-до-каталогу-бота>` на абсолютний шлях до каталогу вашого бота, а `<команда-запуску>` на команду, яку ви отримали [вище](#отримання-команди-запуску).

   Ось коротке пояснення конфігурації сервісу:

   - `After=network.target` --- вказує на те, що додаток повинен запускатися після завантаження інтернет-модуля.
   - `WorkingDirectory=<шлях-до-каталогу-бота>` --- встановлює поточний робочий каталог процесу.
     Це дозволяє використовувати відносні ресурси, як-от файл `.env`, який містить всі необхідні змінні оточення.
   - `ExecStart=<команда-запуску>` --- встановлює команду запуску.
   - `Restart=on-failure` --- вказує на те, що програма повинна перезапускатися у разі збою.
   - `WantedBy=multi-user.target` --- визначає стан системи, в якому повинен запускатися сервіс.
     `multi-user.target` --- типове значення для серверів.

   > Для отримання додаткової інформації про файли служб, прочитайте [це](https://access.redhat.com/documentation/te-in/red_hat_enterprise_linux/9/html/using_systemd_unit_files_to_customize_and_optimize_your_system/assembly_working-with-systemd-unit-files_working-with-systemd).

4. Перезавантажуйте systemd кожного разу, коли ви редагуєте службу:

   ```sh
   systemctl daemon-reload
   ```

#### Керування службою

```sh
# Замініть `<назва-служби>` на назву файлу служби, яку ви створили.

# Щоб запустити службу
systemctl start <назва-служби>

# Щоб переглянути журнали служби
journalctl -u <назва-служби>

# Щоб перезапустити службу
systemctl restart <назва-служби>

# Щоб зупинити службу
systemctl stop <назва-служби>

# Щоб увімкнути запуск служби при завантаженні сервера
systemctl enable <назва-служби>

# Щоб вимкнути запуск служби при завантаженні сервера
systemctl disable <назва-служби>
```

Запуск сервісу має запустити вашого бота!

### PM2

[PM2](https://pm2.keymetrics.io) — це демонічний менеджер процесів для Node.js, який допоможе вам керувати та тримати застосунок в режимі безперервної роботи.

> PM2 створений спеціально для керування застосунками, які написані на Node.js.
> Проте його також можна використовувати для керування застосунками, які написані на інших мовах або середовищах виконання.

#### Встановлення

::: code-group

```sh [NPM]
npm install -g pm2
```

```sh [Yarn]
yarn global add pm2
```

```sh [pnpm]
pnpm add -g pm2
```

:::

#### Створення застосунку

PM2 пропонує два способи створення застосунку:

1. За допомогою інтерфейсу командного рядка.
2. За допомогою [файлу конфігурації](https://pm2.keymetrics.io/docs/usage/application-declaration).

Перший спосіб зручний під час знайомства з PM2.
Проте під час розгортання варто скористатися другим способом, що ми й зробили у нашому випадку.

Створіть файл `ecosystem.config.js` на сервері в каталозі, де зберігається збірка бота, з наступним вмістом:

```js
module.exports = {
  apps: [{
    name: "<назва-застосунку>",
    script: "<команда-запуску>",
  }],
};
```

Замініть `<назва-застосунку>` будь-яким ідентифікатором і `<команда-запуску>` командою запуску бота.

#### Керування застосунком

Нижче наведено команди, за допомогою яких можна керувати застосунком.

```sh
# Якщо файл `ecosystem.config.js` знаходиться в поточному каталозі,
# ви можете нічого не вказувати, щоб запустити застосунок.
# Якщо застосунок вже запущений, то ця команда перезапустить його.
pm2 start

# Всі наступні команди вимагають вказування назви застосунку
# або файлу `ecosystem.config.js`.
# Щоб застосувати дію до всіх застосунків, вкажіть `all`. 

# Щоб перезапустити застосунок
pm2 restart <назва-застосунку>

# Щоб перезавантажити застосунок
pm2 reload <назва-застосунку>

# Щоб зупинити застосунок
pm2 stop <назва-застосунку>

# Щоб видалити застосунок
pm2 delete <назва-застосунку>
```

#### Збереження роботи застосунку

Якщо сервер перезавантажиться, ваш бот не відновить роботу.
Щоб бот відновив роботу, потрібно підготувати PM2 для цього.

В терміналі сервера виконайте наступну команду:

```sh
pm2 startup
```

Вам буде надано команду, яку ви маєте виконати, щоб PM2 автоматично запрацював після перезавантаження серверу.

Після цього виконайте ще одну команду:

```sh
pm2 save
```

Ця команда збереже список поточних застосунків, щоб запустити їх після перезавантаження сервера.

Якщо ви створили новий застосунок і хочете його також зберегти, просто виконайте `pm2 save` знову.

## Запуск бота на вебхуках

Для запуску бота на вебхуках, вам потрібно буде скористатися серверним фреймворком і **не** викликати `bot.start()`.

Ось приклад коду для запуску бота на вебхуках, який слід додати до основного файлу бота:

::: code-group

```ts [Node.js]
import { webhookCallback } from "grammy";
import { fastify } from "fastify";

const server = fastify();

server.post(`/${bot.token}`, webhookCallback(bot, "fastify"));

server.listen();
```

```ts [Deno]
import { webhookCallback } from "https://deno.land/x/grammy/mod.ts";

const handleUpdate = webhookCallback(bot, "std/http");

Deno.serve(async (req) => {
  if (req.method === "POST") {
    const url = new URL(req.url);
    if (url.pathname.slice(1) === bot.token) {
      try {
        return await handleUpdate(req);
      } catch (err) {
        console.error(err);
      }
    }
  }
  return new Response();
});
```

:::

### Оренда домену

Щоб підключити бота, який працює на вебхуках, до зовнішнього світу, вам потрібно придбати домен.
Ми знову будемо пояснювати це на прикладі Hostinger, але є багато інших сервісів, і всі вони працюють аналогічно.

Перейдіть на [сторінку пошуку доменного імені](https://hostinger.com.ua/kupyty-domen).
У полі для введення тексту введіть доменне ім'я у вигляді `<ім'я>.<зона>`.
Наприклад, `example.com`.

Якщо потрібний домен вільний, натисніть кнопку "Додати" поруч з ним.
Ви будете автоматично перенаправлені на сторінку оформлення замовлення, де також відразу ж зареєструєтесь у Hostinger, якщо ви ще не зареєстровані.
Оплатіть домен.

#### Направлення домена на VPS

Перш ніж ваш домен зможе працювати з VPS, вам потрібно направити домен на ваш сервер.
Для цього в [панелі керування Hostinger](https://hpanel.hostinger.com) натисніть кнопку "Керування" навпроти вашого домену.
Далі перейдіть на сторінку управління DNS-записами, натиснувши на кнопку "DNS / Сервери імен" в меню ліворуч.

> Спершу дізнайтеся IP-адресу свого VPS.

У списку DNS-записів знайдіть запис типу `A` з імʼям `@`.
Відредагуйте цей запис, змінивши IP-адресу в полі "Вказує на" на IP-адресу вашого VPS і встановивши TTL рівним 3600.

Далі знайдіть і видаліть запис типу `CNAME` з імʼям `www`.
Замість нього створіть новий запис типу `A` з імʼям `www`, що вказуватиме на IP-адресу вашого VPS, і встановіть TTL рівним 3600.

> Якщо у вас виникнуть проблеми, скористайтеся іншим способом, описаним в [базі знань](https://support.hostinger.com/en/articles/1583227-how-to-point-a-domain-to-your-vps).

### Налаштування вебсервера

Щоб сайт запрацював, а бот почав отримувати оновлення від Telegram, потрібно налаштувати вебсервер.
Ми скористаємося [Caddy](https://caddyserver.com).

Caddy --- це потужний вебсервер з відкритим вихідним кодом і автоматичним HTTPS.

::: tip Вебсервер
Ми використовуємо Caddy, тому що, на відміну від поширених вебсерверів, як-от Nginx або Apache, він автоматично налаштовує SSL-сертифікати.
Це значно спрощує посібник.
Втім, ви можете вибрати будь-який вебсервер, який вам подобається.
:::

#### Встановлення

Наступні пʼять команд завантажать й автоматично запустять Caddy як службу systemd з назвою `caddy`.

```sh
apt install -y debian-keyring debian-archive-keyring apt-transport-https curl
curl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/gpg.key' | gpg --dearmor -o /usr/share/keyrings/caddy-stable-archive-keyring.gpg
curl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/debian.deb.txt' | tee /etc/apt/sources.list.d/caddy-stable.list
apt update
apt install caddy
```

> Дивіться [посібник зі встановлення Caddy](https://caddyserver.com/docs/install) для інших варіантів встановлення.

Перевірте статус роботи Caddy:

```sh
systemctl status caddy
```

:::details Усунення помилок
Деякі провайдери надають VPS із передвстановленим вебсервером, наприклад, [Apache](https://httpd.apache.org).
Кілька вебсерверів не можуть одночасно працювати на одній машині.
Щоб Caddy працював, потрібно зупинити й вимкнути інший вебсервер:

```sh
systemctl stop <назва-служби>
systemctl disable <назва-служби>
```

Замініть `назва-служби` на назву служби вебсервера, який перешкоджає роботі Caddy.

:::

Тепер, якщо ви відкриєте у браузері IP-адресу свого сервера, то побачите типову сторінку з інструкцією по налаштуванню Caddy.

#### Конфігурування

Щоб Caddy обробляв запити, які надходять до нашого домену, потрібно змінити конфігурацію Caddy.

Виконайте наступну команду, щоб відкрити файл конфігурації Caddy:

```sh
nano /etc/caddy/Caddyfile
```

Ви побачите наступну типову конфігурацію:

```text
# The Caddyfile is an easy way to configure your Caddy web server.
#
# Unless the file starts with a global options block, the first
# uncommented line is always the address of your site.
#
# To use your own domain name (with automatic HTTPS), first make
# sure your domain's A/AAAA DNS records are properly pointed to
# this machine's public IP, then replace ":80" below with your
# domain name.

:80 {
  # Set this path to your site's directory.
  root * /usr/share/caddy

  # Enable the static file server.
  file_server

  # Another common task is to set up a reverse proxy:
  # reverse_proxy localhost:8080

  # Or serve a PHP site through php-fpm:
  # php_fastcgi localhost:9000
}

# Refer to the Caddy docs for more information:
# https://caddyserver.com/docs/caddyfile
```

Для обробки вхідних запитів, приведіть конфіг до наступного вигляду:

```text
<домен> {
  reverse_proxy /<токен-бота> localhost:<порт>
}
```

Замініть `<домен>` на ваш домен, `<токен-бота>` на токен бота і `<порт>` на порт, на якому ви хочете запустити бота.

Перезавантажуйте Caddy щоразу, як змінюєте файл конфігурації сайту, за допомогою наступної команди:

```sh
systemctl reload caddy
```

Тепер всі запити на адресу `https://<домен>/<токен-бота>` будуть переадресовуватися на адресу `http://localhost:<порт>/<токен-бота>`, на якій працює вебхук бота.

#### Підключення вебхука до Telegram

Залишилося лише повідомити Telegram, куди слід надсилати оновлення.
Для цього відкрийте браузер й відвідайте сторінку за наступним посиланням:

```text
https://api.telegram.org/bot<токен-бота>/setWebhook?url=https://<домен>/<токен-бота>
```

Замініть `<токен-бота>` на токен вашого бота, а `<домен>` на ваш домен.

## CI/CD

[CI/CD](https://about.gitlab.com/topics/ci-cd) --- це важлива складова сучасного процесу розробки програмного забезпечення.
Цей посібник охоплює майже весь [конвеєр CI/CD](https://about.gitlab.com/topics/ci-cd/cicd-pipeline).

Ми зосередимося на написанні скриптів для GitHub та GitLab.
Ви можете легко адаптувати наведені нижче приклади до вашого сервісу CI/CD, наприклад, Jenkins, Buddy тощо, якщо це необхідно.

### SSH-ключі

Для доставки файлів на сервер вам потрібно налаштувати безпарольну автентифікацію, яка реалізується за допомогою SSH-ключів.

Наступні команди мають виконуватися на вашому персональному компʼютері.

Перейдіть до каталогу з SSH-ключами:

```sh
cd ~/.ssh
```

Згенеруйте нову пару ключів:

::: code-group

```sh [GitHub]
ssh-keygen -t rsa -m PEM
```

```sh [GitLab]
ssh-keygen -t ed25519
```

:::

Ця команда згенерує публічний та приватний ключ потрібного для GitHub та GitLab типу та формату.
За потреби ви можете вказати власну назву ключа.

Далі надішліть **публічний** ключ на сервер:

```sh
ssh-copy-id -i <назва-ключа>.pub root@<ip-адреса>
```

Замініть `<назва-ключа>` на назву згенерованого ключа, а `<ip-адреса>` на IP-адресу вашого сервера.

Зауважте, що **публічний** ключ може розташовуватися на багатьох серверах, а **приватний** ключ має бути лише у вас і у GitHub або GitLab.

Тепер ви можете підключитися до сервера без необхідності введення паролю.

### Приклади сценаріїв виконання завдань

#### Node.js (GitHub)

Використайте

```yml
name: Main

on:
  push:
    branches:
      - main

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0
      - uses: actions/setup-node@v3
        with:
          node-version: "latest"
      - run: npm ci
      - name: Build
        run: npm run build
      - uses: actions/upload-artifact@v3
        with:
          name: source
          path: |
            dist/*.js
            package.json
            package-lock.json
  deploy:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/download-artifact@v3
        with:
          name: source
          path: dist/
      - name: Deploy
        uses: easingthemes/ssh-deploy@v4
        env:
          SOURCE: "dist package.json package-lock.json"
          ARGS: "--delete -az"
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          REMOTE_HOST: ${{ secrets.REMOTE_HOST }}
          REMOTE_USER: ${{ secrets.REMOTE_USER }}
          TARGET: "<цільовий-каталог>"
          SCRIPT_AFTER: |
            cd <цільовий-каталог>
            npm i --omit=dev
            <команда-запуску>
```

де `<цільовий-каталог>` замінюється на назву каталогу, в якому на сервері зберігається збірка бота, а `<команда-запуску>` на команду запуску вашого бота, якою може бути, наприклад, виклик `pm2` або `systemctl`.

Цей скрипт послідовно виконує два завдання: `build` та `deploy`.
Після виконання `build` артефакт цього завдання, а саме каталог `dist`, що містить збірку бота, передається завданню `deploy`.

Файли доставляються на сервер за допомогою утиліти `rsync`, яка реалізована за допомогою `easingthemes/ssh-deploy`.
Після доставки файлів на сервері виконується команда, описана в змінній середовища `SCRIPT_AFTER`.
У нашому випадку після доставки файлів ми переходимо в каталог бота, де встановлюємо всі залежності, окрім `devDependencies`, і перезапускаємо бота.

Зауважте, що вам потрібно додати три [секретні змінні середовища](https://docs.github.com/en/actions/security-guides/using-secrets-in-github-actions):

1. `SSH_PRIVATE_KEY` --- тут має зберігатися приватний SSH-ключ, який ви створили на [попередньому кроці](#ssh-ключі).
2. `REMOTE_HOST` --- тут має зберігатися IP-адреса вашого серверу.
3. `REMOTE_USER` --- тут має зберігатися імʼя користувача, від імені якого запускається бот.

#### Node.js (GitLab)

Використайте

```yml
image: node:latest

stages:
  - build
  - deploy

Build:
  stage: build
  before_script: npm ci
  script: npm run build
  artifacts:
    paths:
      - dist/

Deploy:
  stage: deploy
  before_script:
    - "command -v ssh-agent >/dev/null || ( apt-get update -y && apt-get install openssh-client -y )"
    - "command -v rsync >/dev/null || ( apt-get update -y && apt-get install rsync -y )"
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan "$REMOTE_HOST" >> ~/.ssh/known_hosts
    - chmod 644 ~/.ssh/known_hosts
  script:
    - rsync --delete -az dist package.json package-lock.json $REMOTE_USER@$REMOTE_HOST:<цільовий-каталог>
    - ssh $REMOTE_USER@$REMOTE_HOST "cd <цільовий-каталог> && npm i --omit=dev && <команда-запуску>"
```

де `<цільовий-каталог>` замінюється на назву каталогу, в якому на сервері зберігається збірка бота, а `<команда-запуску>` на команду запуску вашого бота, якою може бути, наприклад, виклик `pm2` або `systemctl`.

Цей скрипт послідовно виконує два завдання: `build` та `deploy`.
Після виконання `build` артефакт цього завдання, а саме каталог `dist`, що містить збірку бота, передається завданню `deploy`.

Файли доставляються на сервер за допомогою утиліти `rsync`, яку необхідно встановити перед виконанням основного скрипта.
Після того, як файли будуть доставлені, ми підключаємося до сервера за допомогою SSH, щоб виконати команду для встановлення всіх залежностей, окрім `devDependencies`, і перезапуску застосунку.

Зауважте, що вам потрібно додати три [змінні середовища](https://docs.gitlab.com/ee/ci/variables):

1. `SSH_PRIVATE_KEY` --- тут має зберігатися приватний SSH-ключ, який ви створили на [попередньому кроці](#ssh-ключі).
2. `REMOTE_HOST` --- тут має зберігатися IP-адреса вашого сервера.
3. `REMOTE_USER` --- тут має зберігатися імʼя користувача, від імені якого запускається бот.

#### Deno (GitHub)

Використайте

```yml
name: Main

on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0
      - name: Deploy
        uses: easingthemes/ssh-deploy@v4
        env:
          SOURCE: "src deno.jsonc deno.lock"
          ARGS: "--delete -az"
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          REMOTE_HOST: ${{ secrets.REMOTE_HOST }}
          REMOTE_USER: ${{ secrets.REMOTE_USER }}
          TARGET: "<цільовий-каталог>"
          SCRIPT_AFTER: |
            cd <цільовий-каталог>
            <команда-запуску>
```

де `<цільовий-каталог>` замінюється на назву каталогу, в якому на сервері зберігається збірка бота, а `<команда-запуску>` на команду запуску вашого бота, якою може бути, наприклад, виклик `pm2` або `systemctl`.

Цей скрипт доставляє файли на сервер за допомогою утиліти `rsync`, яка реалізована за допомогою `easingthemes/ssh-deploy`.
Після доставки файлів на сервері виконується команда, описана в змінній середовища `SCRIPT_AFTER`.
У нашому випадку після доставки файлів ми переходимо в каталог бота і перезапускаємо його.

Зауважте, що вам потрібно додати три [секретні змінні середовища](https://docs.github.com/en/actions/security-guides/using-secrets-in-github-actions):

1. `SSH_PRIVATE_KEY` --- тут має зберігатися приватний SSH-ключ, який ви створили на [попередньому кроці](#ssh-ключі).
2. `REMOTE_HOST` --- тут має зберігатися IP-адреса вашого серверу.
3. `REMOTE_USER` --- тут має зберігатися імʼя користувача, від імені якого запускається бот.

#### Deno (GitLab)

Використайте

```yml
image: denoland/deno:latest

stages:
  - deploy

Deploy:
  stage: deploy
  before_script:
    - "command -v ssh-agent >/dev/null || ( apt-get update -y && apt-get install openssh-client -y )"
    - "command -v rsync >/dev/null || ( apt-get update -y && apt-get install rsync -y )"
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan "$REMOTE_HOST" >> ~/.ssh/known_hosts
    - chmod 644 ~/.ssh/known_hosts
  script:
    - rsync --delete -az src deno.jsonc deno.lock $REMOTE_USER@$REMOTE_HOST:<цільовий-каталог>
    - ssh $REMOTE_USER@$REMOTE_HOST "cd <цільовий-каталог> && npm i --omit=dev && <команда-запуску>"
```

де `<цільовий-каталог>` замінюється на назву каталогу, в якому на сервері зберігається збірка бота, а `<команда-запуску>` на команду запуску вашого бота, якою може бути, наприклад, виклик `pm2` або `systemctl`.

Файли доставляються на сервер за допомогою утиліти `rsync`, яку необхідно встановити перед виконанням основного скрипта.

Після того, як файли будуть доставлені, ми підключаємося до сервера за допомогою SSH, щоб перейти в каталог бота і перезапустити бота.

Зауважте, що вам потрібно додати три [змінні середовища](https://docs.gitlab.com/ee/ci/variables):

1. `SSH_PRIVATE_KEY` --- тут має зберігатися приватний SSH-ключ, який ви створили на [попередньому кроці](#ssh-ключі).
2. `REMOTE_HOST` --- тут має зберігатися IP-адреса вашого сервера.
3. `REMOTE_USER` --- тут має зберігатися імʼя користувача, від імені якого запускається бот.

Тепер ви повинні побачити, як кожну публікацію коду до гілки `main` буде автоматично розгорнуто на вашому VPS.
Розробка рушила :rocket:
