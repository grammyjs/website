---
prev: ./context.md
next: ./filter-queries.md
---

# Bot API

## Загальні відомості

Боти Telegram спілкуються з серверами Telegram через HTTP запити.
Telegram Bot API — це специфікація цього інтерфейсу, тобто [довгий список](https://core.telegram.org/bots/api) методів і типів даних, який зазвичай називають довідкою.
Він визначає все, що можуть робити боти Telegram.
Посилання на нього можна знайти на вкладці «Ресурси».

Цю систему можна візуалізувати наступним чином:

```asciiart:no-line-numbers
( ( ( Telegram ) MTProto API ) Bot HTTP API ) <-- бот підключається тут
```

Пояснення: коли ваш бот надсилає повідомлення, воно надсилається як HTTP запит на _сервер Bot API_, розміщений командою Telegram або [особисто вами](https://core.telegram.org/bots/api#using-a-local-bot-api-server).
Цей сервер перекладатиме запит на власний протокол Telegram під назвою MTProto та надсилатиме запит до серверної частини Telegram, яка піклується про надсилання повідомлення користувачеві.

Так само щоразу, коли користувач відповідає, відбувається зворотний шлях.

::: tip Обхід обмежень на розмір файлу
Сервер Telegram дозволяє вашому боту [надсилати файли](./files.md) розміром до 2000 МБ.
Однак сервер Bot API, який відповідає за переклад запитів на протокол HTTP, обмежує розмір файлу до 50 МБ для завантаження з серверу та 20 МБ для завантаження на сервер.

Отже, якщо ви обійдете сервер Bot API, який Telegram запускає для вас, і просто [розмістите свій власний сервер Bot API](https://core.telegram.org/bots/api#using-a-local-bot-api-сервер), ви можете дозволити своєму боту надсилати файли розміром до 2000 МБ.

> Примітка: якщо ви працюєте з великими файлами через [довге опитування](./deployment-types.md), вам варто використовувати [конкурентність для grammY](../plugins/runner.md).

:::

## Виклик Bot API

Кожен окремий метод Bot API має еквівалент у grammY.
Наприклад: `sendMessage` у [довіднику Telegram Bot API](https://core.telegram.org/bots/api#sendmessage) і [довіднику API grammY](https://deno.land/x/grammy/mod.ts?s=Api#method_sendMessage_0).

### Виклик метода

Ви можете викликати методи API через `bot.api` або [так само](./context.md#%D0%B4%D0%BE%D1%81%D1%82%D1%83%D0%BF%D0%BD%D1%96-%D0%B4%D1%96%D1%96) через `ctx.api`:

```ts
async function sendHelloTo12345() {
  // Відправляємо повідомлення користувачу з id 12345.
  await bot.api.sendMessage(12345, "Привіт!");

  // Надсилаємо повідомлення та зберегігаємо відповідь, яка містить інформацію про надіслане повідомлення.
  const sentMessage = await bot.api.sendMessage(12345, "Привіт знову!");
  console.log(sentMessage.message_id);
}
```

Хоча `bot.api` покриває весь Bot API, він іноді дещо змінює сигнатури функцій, щоб зробити його зручнішим у використанні.
Власне, усі методи Bot API очікують об’єкт JSON із певними властивостями.
Утім зверніть увагу, як `sendMessage` у наведеному вище прикладі отримує два аргументи: ідентифікатор чату та рядок.
grammY знає, що ці два значення належать властивостям `chat_id` і `text` відповідно, і створить для вас правильний об’єкт JSON.

Як згадувалося [раніше](./basics.md#надсилання-повідомлень), ви можете вказати інші параметри в третьому аргументі типу `Other`:

```ts
async function sendHelloTo12345() {
  await bot.api.sendMessage(12345, "<i>Привіт!</i>", {
    parse_mode: "HTML",
  });
}
```

Крім того, grammY піклується про численні технічні деталі, щоб спростити використання API.
Наприклад, деякі конкретні властивості в деяких конкретних методах мають бути `JSON.stringify` перед їх надсиланням.
Це легко забути, важко налагодити та порушує визначення типу.
grammY дозволяє вам узгоджено вказувати об’єкти в API та забезпечує серіалізацію правильних властивостей на льоту перед їх надсиланням.

### Визначення типів для API

grammY постачається з повним покриттям типів Bot API.
Репозиторій [`@grammyjs/types`](https://github.com/grammyjs/types) містить визначення типів, які grammY використовує для внутрішнього використання.
Ці визначення типів також експортуються, щоб ви могли використовувати їх у власному коді.

#### Визначення типів у Deno

У Deno ви можете просто імпортувати визначення типів із `types.ts`, який знаходиться поруч із `mod.ts`:

```ts
import { type Chat } from "https://deno.land/x/grammy/types.ts";
```

#### Визначення типів у Node.js

На Node.js це складніше.
Вам потрібно імпортувати типи з `grammy/types`.
Наприклад, ви отримуєте доступ до типу `Chat` таким чином:

```ts
import { type Chat } from "grammy/types";
```

Однак офіційно Node.js підтримує належний імпорт підшляхів, починаючи лише з Node.js 16.
Отже, TypeScript вимагає, щоб `moduleResolution` було встановлено на `node16` або `nodenext`.
Налаштуйте відповідно свій `tsconfig.json` і додайте виділений рядок:

```json{4}
{
  "compilerOptions": {
    // ...
    "moduleResolution": "node16"
    // ...
  }
}
```

У деяких випадках це також може працювати без налаштування конфігурації TypeScript.

::: warning Неправильне автодоповнення

Якщо ви не зміните свій файл `tsconfig.json`, як описано вище, може статися так, що ваш редактор коду запропонує в автодоповненні імпортувати типи з `grammy/out/client` або щось подібне.
**Усі шляхи, що починаються з `grammy/out` є внутрішніми. Не використовуйте їх.**
Вони можуть бути довільно змінені в будь-коли, тому ми настійно рекомендуємо вам імпортувати типи з `grammy/types`.

:::

### Виклики Raw API

Бувають випадки, коли ви захочете використовувати оригінальні сигнатури функцій, але все одно покладаєтеся на зручність API grammY: наприклад, серіалізація JSON, де це доречно.
grammY підтримує це за допомогою властивостей `bot.api.raw` або `ctx.api.raw`.

Ви можете викликати raw методи так:

```ts
async function sendHelloTo12345() {
  await bot.api.raw.sendMessage({
    chat_id: 12345,
    text: "<i>Привіт!</i>",
    parse_mode: "HTML",
  });
}
```

По суті, всі параметри даних сигнатури функції об’єднуються з об’єктом параметрів, коли ви використовуєте Raw API.
