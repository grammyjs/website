---
prev: ./basics.md
next: ./api.md
---

# Контекст

Об’єкт `Context` ([довідник API grammY](https://deno.land/x/grammy/mod.ts?s=Context)) є важливою частиною grammY.

Кожного разу, коли ви реєструєте обробника на своєму об’єкті бота, цей обробник отримає об’єкт контексту.

```ts
bot.on("message", (ctx) => {
  // `ctx` - це об'єкт `Context`.
});
```

Ви можете використовувати об’єкт контексту, щоб

- [отримати інформацію про повідомлення](#доступна-інформація),
- [виконати дії у відповідь на повідомлення](#%D0%B4%D0%BE%D1%81%D1%82%D1%83%D0%BF%D0%BD%D1%96-%D0%B4%D1%96%D1%96).

Зауважте, що об’єкти контексту зазвичай називають `ctx`.

## Доступна інформація

Коли користувач надсилає повідомлення вашому боту, ви можете отримати доступ до цього повідомлення через `ctx.message`.
Наприклад, щоб отримати текст повідомлення, ви можете зробити наступне:

```ts
bot.on("message", (ctx) => {
  // Під час обробки текстових повідомлень `txt` буде типу `string`.
  // Буде `undefined`, якщо отримане повідомлення не містить текст.
  // Наприклад, фотографії, стікери тощо.
  const txt = ctx.message.text;
});
```

Так само ви можете отримати доступ до інших властивостей об’єкта повідомлення: `ctx.message.chat` для інформації про чат, куди було надіслано повідомлення.
Щоб дізнатися, які дані доступні, перегляньте [частину про `Message` в довіднику Telegram Bot API](https://core.telegram.org/bots/api#message).
Крім того, ви можете просто скористатися автодоповненням у своєму редакторі коду, щоб побачити можливі варіанти.

Якщо ви зареєструєте свій обробник для інших типів, `ctx` також надасть вам інформацію про них.
Наприклад:

```ts
bot.on("edited_message", (ctx) => {
  // Отримайте новий, відредагований, текст повідомлення.
  const editedText = ctx.editedMessage.text;
});
```

Ба більше, ви можете отримати доступ до необробленого об’єкта `Update` ([довідка Telegram Bot API](https://core.telegram.org/bots/api#update)), який Telegram надсилає вашому боту.
Цей об’єкт оновлення (`ctx.update`) містить усі дані, які є джерелом інформації для `ctx.message` та інших методів.

Об’єкт контексту завжди містить інформацію про вашого бота, яка доступна через `ctx.me`.

### Скорочені методи

Для об’єкта контексту встановлено кілька скорочених методів.

| Скорочений метод      | Опис                                                                                                              |
| --------------------- | ----------------------------------------------------------------------------------------------------------------- |
| `ctx.msg`             | Отримує обʼєкт повідомлення (навіть редагованого)                                                                 |
| `ctx.chat`            | Отримує обʼєкт чату                                                                                               |
| `ctx.senderChat`      | Отримує об’єкт чату відправника з `ctx.msg` (для повідомлень з анонімних каналів/груп)                            |
| `ctx.from`            | Отримує автора повідомлення, запиту зворотного виклику тощо                                                       |
| `ctx.inlineMessageId` | Отримує ідентифікатор вбудованого повідомлення для запитів зворотного виклику або вибраних вбудованих результатів |
| `ctx.entities`        | Отримує сутності повідомлення та їхній текст, необов’язково відфільтрований за типом сутності                     |

Іншими словами, ви також можете зробити це:

```ts
bot.on("message", (ctx) => {
  // Отримайте текст повідомлення.
  const text = ctx.msg.text;
});

bot.on("edited_message", (ctx) => {
  // Отримайте новий, відредагований, текст повідомлення.
  const editedText = ctx.msg.text;
});

bot.on("message:entities", (ctx) => {
  // Отримайте всі сутності.
  const entities = ctx.entities();

  // Отримайте текст першої сутності.
  entities[0].text;

  // Отримайте сутності електронної пошти.
  const emails = ctx.entities("email");

  // Отримайте сутності телефону та електронної пошти.
  const phonesAndEmails = ctx.entities(["email", "phone"]);
});
```

Отже, якщо ви хочете, ви можете забути про `ctx.message` і `ctx.channelPost`, і `ctx.editedMessage`, і т.д., і т.п., і завжди використовувати замість них `ctx.msg`.

## Дослідження через has перевірку

Контекстний об’єкт має декілька методів, які дозволяють перевіряти певні дані у вмісті.
Наприклад, ви можете викликати `ctx.hasCommand("start")`, щоб перевірити, чи містить об’єкт контексту команду `/start`.
Ось чому методи мають загальну назву _has перевірка_.

::: tip Знайте, коли використовувати, has перевірки

Це точно та ж логіка, яку використовує `bot.command("start")`.
Зауважте, що зазвичай слід використовувати [фільтрування запитів](./filter-queries.md) і подібні методи.
Використання has перевірок найкраще працює в [плагіні розмов](../plugins/conversations.md).

:::

Has перевірки правильно звужують тип контексту.
Це означає, що перевірка, чи містить контекст дані запиту зворотного виклику, повідомить TypeScript, що контекст має поле `ctx.callbackQuery.data`.

```ts
if (ctx.hasCallbackQuery(/query-data-\d+/)) {
  // Тепер відомо, що `ctx.callbackQuery.data` присутній тут
  const data: string = ctx.callbackQuery.data;
}
```

Те саме стосується всіх інших перевірок.
Перегляньте [довідку API про об’єкт контексту](https://deno.land/x/grammy/mod.ts?s=Context#method_has_0), щоб побачити список усіх has перевірок.
Також перегляньте статичну властивість `Context.has` у [довідці API](https://deno.land/x/grammy/mod.ts?s=Context#Static_Properties), яка дозволяє створювати ефективні предикатні функції для дослідження багатьох об'єктів контексту.

## Доступні дії

Якщо ви хочете відповісти на повідомлення від користувача, ви можете написати наступне:

```ts
bot.on("message", async (ctx) => {
  // Отримайте ідентифікатор чату.
  const chatId = ctx.msg.chat.id;
  // Текст для відповіді.
  const text = "Я отримав твоє повідомлення!";
  // Надішліть відповідь.
  await bot.api.sendMessage(chatId, text);
});
```

Ви можете помітити дві речі, які не є оптимальними в цьому прикладі:

1. Ми повинні мати доступ до об’єкта `bot`.
   Це означає, що ми маємо передати об’єкт `bot` всій кодовій базі, щоб відповісти, що дратує, коли у вас є більше ніж один вихідний файл і ви визначаєте свій обробник десь в іншому місці.
2. Ми повинні вилучити ідентифікатор чату з контексту та знову явно передати його в `sendMessage`.
   Це теж дратує, тому що ви, швидше за все, завжди хочете відповідати тому самому користувачеві, який надіслав повідомлення.
   Уявіть, як часто ви вводите те саме знову і знову!

Щодо першого пункту об’єкт контексту просто надає вам доступ до того самого об’єкта API, який ви знайдете в `bot.api`, він називається `ctx.api`.
Тепер ви можете замість цього написати `ctx.api.sendMessage`, і вам більше не доведеться передавати об’єкт `bot`.
Зручно.

Однак справжня сила полягає у виправленні другого пункту.
Об’єкт контексту дозволяє просто надіслати відповідь так:

```ts
bot.on("message", async (ctx) => {
  await ctx.reply("Я отримав твоє повідомлення!");
});

// Або ще коротше:
bot.on("message", (ctx) => ctx.reply("Впіймав!"));
```

Лаконічно! :tada:

Під капотом контекст _вже знає свій ідентифікатор чату_: `ctx.msg.chat.id`, тому він дає вам метод `відповіді`, щоб просто надіслати повідомлення назад у той самий чат.
Всередині себе `reply` знову викликає `sendMessage` із попередньо заповненим для вас ідентифікатором чату.

Отже, усі методи об’єкта контексту приймають об’єкти параметрів типу `Other`, як пояснювалося [раніше](./basics.md#sending-messages).
Це можна використати для передачі подальших налаштувань кожному виклику API.

::: tip Функція відповіді Telegram
Незважаючи на те, що в grammY (та багатьох інших фреймворках) метод називається `ctx.reply`, він не використовує [функцію відповіді Telegram](https://telegram.org/blog/replies-mentions-hashtags#replies) де є посилання на попереднє повідомлення.

Якщо ви подивитеся у [довіднику Telegram Bot API](https://core.telegram.org/bots/api#sendmessage), що може робити `sendMessage`, ви побачите кілька параметрів: `parse_mode`, `disable_web_page_preview` і `reply_to_message_id`.
Останнє можна використати, щоб зробити повідомлення відповіддю:

```ts
await ctx.reply("^ Це повідомлення!", {
  reply_to_message_id: ctx.msg.message_id,
});
```

Той самий об’єкт параметрів можна передати в `bot.api.sendMessage` і `ctx.api.sendMessage`.
Використовуйте автодоповнення, щоб побачити доступні параметри прямо в редакторі коду.
:::

Звичайно, кожен інший метод у `ctx.api` має короткий метод із правильними попередньо заповненими значеннями: `ctx.replyWithPhoto`, щоб відповісти фотографією, або `ctx.exportChatInviteLink`, щоб отримати посилання для запрошення до відповідного чату.
Якщо ви хочете отримати загальне уявлення про те, які короткі методи існують, тоді автодоповнення стане вашим другом разом із [довідкою API grammY](https://deno.land/x/grammy/mod.ts?s=Context).

Зауважте, що вам не зажди потрібно працювати в тому ж чаті.
У цьому випадку ви можете просто повернутися до використання методів `ctx.api` і вказати всі параметри під час їх виклику.
Наприклад, якщо ви отримали повідомлення від Аліси та хочете відреагувати, надіславши повідомлення Бобу, ви не можете використовувати `ctx.reply`, оскільки він завжди надсилатиме повідомлення до чату з Алісою.
Натомість викличте `ctx.api.sendMessage` і вкажіть ідентифікатор чату Боба.

## Як створюються об’єкти контексту

Щоразу, коли ваш бот отримує нове повідомлення від Telegram, воно загортається в об’єкт оновлення.
Насправді об’єкти оновлення можуть містити не лише нові повідомлення, а й усі інші речі, як-от редагування повідомлень, відповіді на опитування та [багато іншого](https://core.telegram.org/bots/api#update).

Новий об’єкт контексту створюється виключно один раз для кожного вхідного оновлення.
Контексти для різних оновлень абсолютно непов’язані об’єкти, вони лише посилаються на ту саму інформацію про бота через `ctx.me`.

Той самий об’єкт контексту для одного оновлення буде спільно використовуватися всіма встановленими на боті middlaware ([документація](./middleware.md)).

## Налаштування об’єкта контексту

> Якщо ви вперше знайомитеся з об’єктами контексту, вам не потрібно турбуватися про решту цієї сторінки.

За бажанням ви можете встановити власні властивості в об’єкті контексту.

### Через middleware (рекомендовано)

Налаштування можна легко виконати в [middleware](./middleware.md).

::: tip Middle... що?
Цей розділ потребує розуміння middleware, тому, якщо ви ще не переходили до [розділу про middleware](./middleware.md), ось дуже короткий підсумок.

Все, що вам справді потрібно знати, це те, що кілька обробників можуть обробляти один контекстний об’єкт.
Існують спеціальні обробники, які можуть змінювати `ctx` перед запуском будь-яких інших обробників, і зміни першого обробника будуть видимі для всіх наступних обробників.
:::

Ідея полягає в тому, щоб встановити middleware перед реєстрацією інших обробників.
Потім ви можете встановити потрібні властивості в цих обробниках.
Якщо ви застосовуєте `ctx.yourCustomPropertyName = yourCustomValue` всередині такого обробника, то властивість `ctx.yourCustomPropertyName` також буде доступна в інших обробниках.

Для ілюстрації припустімо, що ви хочете встановити властивість під назвою `ctx.config` для об’єкта контексту.
У цьому прикладі ми будемо використовувати його для збереження деяких налаштувань проєкту, щоб усі обробники мали до них доступ.
Налаштування полегшить виявлення того, ким використовується бот: його розробником чи звичайним користувачем.

Відразу після створення бота виконайте наступне:

```ts
const BOT_DEVELOPER = 123456; // ідентифікатор чату розробника бота

bot.use(async (ctx, next) => {
  // Змініть об’єкт контексту, встановивши налаштування.
  ctx.config = {
    botDeveloper: BOT_DEVELOPER,
    isDeveloper: ctx.from?.id === BOT_DEVELOPER,
  };
  // Запустіть інші обробники.
  await next();
});
```

Після цього ви можете використовувати `ctx.config` в інших обробниках.

```ts
bot.command("start", async (ctx) => {
  // Працюйте тут зі зміненим контекстом!
  if (ctx.config.isDeveloper) await ctx.reply("Привіт, ма!! <3");
  else await ctx.reply("Ласкаво просимо, людино!");
});
```

Однак ви помітите, що TypeScript не знає, що `ctx.config` доступний, навіть якщо ми призначаємо властивість правильно.
Таким чином, хоча код працюватиме під час виконання, він не скомпілюється.
Щоб виправити це, нам потрібно налаштувати тип контексту та додати властивість.

```ts
interface BotConfig {
  botDeveloper: number;
  isDeveloper: boolean;
}

type MyContext = Context & {
  config: BotConfig;
};
```

Новий тип `MyContex` тепер точно описує об’єкти контексту, які насправді обробляє наш бот.

> Вам потрібно переконатися, що ви підтримуєте синхронізацію типів із властивостями, які ви ініціалізуєте.

Ми можемо використовувати новий тип, передавши його в конструктор `Bot`.

```ts
const bot = new Bot<MyContext>("");
```

У підсумку налаштування виглядатимуть наступним чином:

<CodeGroup>
  <CodeGroupItem title="TypeScript" active>

```ts
const BOT_DEVELOPER = 123456; // ідентифікатор чату розробника бота

// Визначте власний тип контексту.
interface BotConfig {
  botDeveloper: number;
  isDeveloper: boolean;
}
type MyContext = Context & {
  config: BotConfig;
};

const bot = new Bot<MyContext>("");

// Встановіть настроювані властивості об’єктів контексту.
bot.use(async (ctx, next) => {
  ctx.config = {
    botDeveloper: BOT_DEVELOPER,
    isDeveloper: ctx.from?.id === BOT_DEVELOPER,
  };
  await next();
});

// Визначте обробники для настроюваних контекстних об’єктів.
bot.command("start", async (ctx) => {
  if (ctx.config.isDeveloper) await ctx.reply("Привіт, ма!");
  else await ctx.reply("Ласкаво просимо");
});
```

</CodeGroupItem>
  <CodeGroupItem title="JavaScript">

```js
const BOT_DEVELOPER = 123456; // ідентифікатор чату розробника бота

const bot = new Bot("");

// Встановіть настроювані властивості об’єктів контексту.
bot.use(async (ctx, next) => {
  ctx.config = {
    botDeveloper: BOT_DEVELOPER,
    isDeveloper: ctx.from?.id === BOT_DEVELOPER,
  };
  await next();
});

// Визначте обробники для настроюваних контекстних об’єктів.
bot.command("start", async (ctx) => {
  if (ctx.config.isDeveloper) await ctx.reply("Привіт, ма!");
  else await ctx.reply("Ласкаво просимо");
});
```

</CodeGroupItem>
</CodeGroup>

Звичайно, власний тип контексту також можна передати іншим речам, які обробляють middleware, наприклад [composer](https://deno.land/x/grammy/mod.ts?s=Composer).

```ts
const composer = new Composer<MyContext>();
```

Деякі плагіни також вимагатимуть передачі власного типу контексту, як-от плагін [router](../plugins/router.md) або [menu](../plugins/menu.md).
Перегляньте їхню документацію, щоб дізнатися, як вони використовують власний тип контексту.
Ці типи називаються flavors, як описано [тут](#context-flavor).

### Через успадкування

Окрім встановлення власних властивостей об’єкта контексту, ви можете створити підклас класу `Context`.

```ts
class MyContext extends Context {
  // ...
}
```

Однак ми рекомендуємо вам налаштовувати об’єкт контексту [через middleware](#через-middleware-рекомендовано), оскільки він гнучкіший і краще працює, якщо ви хочете встановити плагіни.

Нумо дивитися, як використовувати власні класи для об’єктів контексту.

Під час створення свого бота ви можете передати власний конструктор контексту, який використовуватиметься для створення екземплярів об’єктів контексту.
Зауважте, що ваш клас має розширювати `Context`.

<CodeGroup>
  <CodeGroupItem title="TypeScript" active>

```ts
import { Bot, Context } from "grammy";
import type { Update, UserFromGetMe } from "@grammyjs/types";

// Визначте власний клас контексту.
class MyContext extends Context {
  // Установіть деякі власні властивості.
  public readonly customProp: number;

  constructor(update: Update, api: Api, me: UserFromGetMe) {
    super(update, api, me);
    this.customProp = me.username.length * 42;
  }
}

// Передайте конструктор спеціального класу контексту як параметр.
const bot = new Bot("<token>", {
  ContextConstructor: MyContext,
});

bot.on("message", (ctx) => {
  // `ctx` тепер має тип `MyContext`.
  const prop = ctx.customProp;
});

bot.start();
```

</CodeGroupItem>
  <CodeGroupItem title="JavaScript" active>

```ts
const { Bot, Context } = require("grammy");

// Визначте власний клас контексту.
class MyContext extends Context {
  // Установіть деякі власні властивості.
  public readonly customProp;

  constructor(update, api, me) {
    super(update, api, me);
    this.customProp = me.username.length * 42;
  }
}

// Передайте конструктор спеціального класу контексту як параметр.
const bot = new Bot("<token>", {
  ContextConstructor: MyContext,
});

bot.on("message", (ctx) => {
  // `ctx` тепер має тип `MyContext`.
  const prop = ctx.customProp;
});

bot.start();
```

</CodeGroupItem>
  <CodeGroupItem title="Deno">

```ts
import { Bot, Context } from "https://deno.land/x/grammy/mod.ts";
import type { Update, UserFromGetMe } from "https://esm.sh/@grammyjs/types";

// Визначте власний клас контексту.
class MyContext extends Context {
  // Установіть деякі власні властивості.
  public readonly customProp: number;

  constructor(update: Update, api: Api, me: UserFromGetMe) {
    super(update, api, me);
    this.customProp = me.username.length * 42;
  }
}

// Передайте конструктор спеціального класу контексту як параметр.
const bot = new Bot("<token>", {
  ContextConstructor: MyContext,
});

bot.on("message", (ctx) => {
  // `ctx` тепер має тип `MyContext`.
  const prop = ctx.customProp;
});

bot.start();
```

</CodeGroupItem>
</CodeGroup>

Зверніть увагу на те, як власний тип контексту буде виведено автоматично, коли ви використовуєте підклас.
Вам більше не потрібно писати `Bot<MyContext>`, оскільки ви вже вказали свій конструктор підкласу в об’єкті параметрів `new Bot()`.

Однак це дуже ускладнює, якщо не унеможливлює, встановлення плагінів, оскільки для них часто потрібно встановлювати context falvor.

## Context flavor

Context flavor — це спосіб повідомити TypeScript про нові властивості вашого об’єкта контексту.
Ці нові властивості можна розмістити в плагінах або інших модулях, а потім встановити у вашому боті.

Context flavor також може трансформувати типи існуючих властивостей за допомогою автоматичних процедур, які визначаються плагінами.

### Додаючий context flavor

Як було зазначено вище, існує два різних типи context flavor.
Основний називається _додаючий context flavor_, і щоразу, коли ми говоримо про context flavor, ми маємо на увазі саме цей тип.
Давайте подивимося, як це працює.

Наприклад, якщо у вас є [дані сеансу](../plugins/session.md), ви повинні зареєструвати `ctx.session` для типу контексту.
Інакше:

1. ви не зможете встановити вбудований плагін сеансів,
2. у вас не буде доступу до `ctx.session` у ваших обробниках.

> Незважаючи на те, що ми використовуємо сесії як приклад, подібні речі застосовуються до багатьох інших випадків.
> Насправді більшість плагінів нададуть вам context flavor, який вам потрібно використовувати.

Context flavor — це просто невеликий новий тип, який визначає властивості, які слід додати до типу контексту.
Давайте розглянемо приклад flavor.

```ts
interface SessionFlavor<S> {
  session: S;
}
```

Тип `SessionFlavor` ([довідка API](https://deno.land/x/grammy/mod.ts?s=SessionFlavor)) простий: він визначає лише властивість `session`.
Він приймає параметр типу, який визначатиме фактичну структуру даних сеансу.

Чим це корисно?
Ось як ви можете розширити свій контекст за допомогою даних сеансу:

```ts
import { Context, SessionFlavor } from "grammy";

// Оголосіть `ctx.session` типу `string`.
type MyContext = Context & SessionFlavor<string>;
```

Тепер ви можете використовувати плагін сесії та мати доступ до `ctx.session`:

```ts
bot.on("message", (ctx) => {
  // Тепер `str` має тип `string`.
  const str = ctx.session;
});
```

### Трансформуючий context flavor

Інший тип context flavor є більш потужним.
Замість встановлення за допомогою оператора `&`, їх потрібно встановити так:

```ts
import { Context } from "grammy";
import { SomeFlavorA } from "my-plugin";

type MyContext = SomeFlavorA<Context>;
```

Все інше працює так само.

Кожен офіційний плагін зазначає у своїй документації, чи має він використовуватися через додаючий або трансформуючий context flavor.

### Поєднання різних context flavor

Якщо у вас є різні [додаючі context flavor](#додаючий-context-flavor), ви можете просто встановити їх наступним чином:

```ts
type MyContext = Context & FlavorA & FlavorB & FlavorC;
```

Порядок context flavors не має значення, ви можете комбінувати їх як вам заманеться.

Кілька [трансформуючих context flavors](#трансформуючий-context-flavor) також можна комбінувати:

```ts
type MyContext = FlavorX<FlavorY<FlavorZ<Context>>>;
```

Тут порядок може мати значення, оскільки спочатку `Context` буде перетворено `FlavorZ`, потім `FlavorY`, і результат цього буде знову перетворено вже `FlavorX`.

Ви навіть можете змішувати додаючі та трансформуючі context flavor:

```ts
type MyContext = FlavorX<
  FlavorY<
    FlavorZ<
      Context & FlavorA & FlavorB & FlavorC
    >
  >
>;
```

Обов’язково дотримуйтеся цього шаблону під час встановлення кількох плагінів.
Існує ряд помилок типів, які виникають через неправильне поєднання декількох context flavor.
