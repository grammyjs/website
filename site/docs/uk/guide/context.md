---
prev: ./basics.md
next: ./api.md
---

# Контекст

Об’єкт `Context` ([довідник API grammY](https://deno.land/x/grammy/mod.ts?s=Context)) є важливою частиною grammY.

Кожного разу, коли ви реєструєте обробника на своєму об’єкті бота, цей обробник отримує об’єкт контексту.

```ts
bot.on("message", (ctx) => {
  // `ctx` - це об'єкт `Context`.
});
```

Ви можете використовувати об’єкт контексту, щоб

- [отримати інформацію про повідомлення](#доступна-інформація),
- [виконати дії у відповідь на повідомлення](#%D0%B4%D0%BE%D1%81%D1%82%D1%83%D0%BF%D0%BD%D1%96-%D0%B4%D1%96%D1%96).

Зауважте, що об’єкти контексту зазвичай називають `ctx`.

## Доступна інформація

Коли користувач надсилає повідомлення вашому боту, ви можете отримати доступ до цього повідомлення через `ctx.message`.
Наприклад, щоб отримати текст повідомлення, ви можете зробити наступне:

```ts
bot.on("message", (ctx) => {
  // Під час обробки текстових повідомлень `txt` буде типу `string`.
  // Також може бути `undefined`, якщо отримане повідомлення не містить текст.
  // Наприклад, фотографії, наліпки тощо.
  const txt = ctx.message.text;
});
```

Так само ви можете отримати доступ до інших властивостей об’єкта повідомлення: `ctx.message.chat` для інформації про чат, куди було надіслано повідомлення.
Щоб дізнатися, які дані доступні, перегляньте [частину про `Message` в довіднику Telegram Bot API](https://core.telegram.org/bots/api#message).
Крім того, ви можете просто скористатися автодоповненням у своєму редакторі коду, щоб побачити можливі варіанти.

Якщо ви зареєструєте свій обробник для інших типів, `ctx` також надасть вам інформацію про них.
Наприклад:

```ts
bot.on("edited_message", (ctx) => {
  // Отримуємо новий, відредагований, текст повідомлення.
  const editedText = ctx.editedMessage.text;
});
```

Ба більше, ви можете отримати доступ до оригінального обʼєкту `Update` ([довідка Telegram Bot API](https://core.telegram.org/bots/api#update)), який Telegram надсилає вашому боту.
Цей об’єкт оновлення (`ctx.update`) містить усі дані, які є джерелом інформації для `ctx.message` та інших методів.

Об’єкт контексту завжди містить інформацію про вашого бота, яка доступна через `ctx.me`.

### Скорочені методи

Для об’єкта контексту встановлено кілька скорочених методів.

| Скорочений метод      | Опис                                                                                                               |
| --------------------- | ------------------------------------------------------------------------------------------------------------------ |
| `ctx.msg`             | Повертає обʼєкт повідомлення (навіть редагованого)                                                                 |
| `ctx.chat`            | Повертає обʼєкт чату                                                                                               |
| `ctx.senderChat`      | Повертає об’єкт чату відправника з `ctx.msg` (для повідомлень з анонімних каналів/груп)                            |
| `ctx.from`            | Повертає автора повідомлення, запиту зворотного виклику тощо                                                       |
| `ctx.inlineMessageId` | Повертає ідентифікатор вбудованого повідомлення для запитів зворотного виклику або вибраних вбудованих результатів |
| `ctx.entities`        | Повертає сутності повідомлення та їхній текст, необов’язково відфільтрований за типом сутності                     |

Іншими словами, ви також можете зробити це:

```ts
bot.on("message", (ctx) => {
  // Отримуємо текст повідомлення.
  const text = ctx.msg.text;
});

bot.on("edited_message", (ctx) => {
  // Отримуємо новий, відредагований, текст повідомлення.
  const editedText = ctx.msg.text;
});

bot.on("message:entities", (ctx) => {
  // Отримуємо всі сутності.
  const entities = ctx.entities();

  // Отримуємо текст першої сутності.
  entities[0].text;

  // Отримуємо сутності електронної пошти.
  const emails = ctx.entities("email");

  // Отримуємо сутності телефону та електронної пошти.
  const phonesAndEmails = ctx.entities(["email", "phone"]);
});
```

Отже, якщо ви хочете, ви можете забути про `ctx.message` і `ctx.channelPost`, і `ctx.editedMessage`, і т.д., і т.п., та завжди використовувати замість них `ctx.msg`.

## Дослідження через has перевірку

Обʼєкт контексту має декілька методів, які дозволяють перевіряти наявність певних даних у вмісті.
Наприклад, ви можете викликати `ctx.hasCommand("start")`, щоб перевірити, чи містить об’єкт контексту команду `/start`.
Ось чому методи мають загальну назву _has перевірка_.

::: tip Коли використовувати has перевірки

Це точно та ж логіка, яку використовує `bot.command("start")`.
Зауважте, що зазвичай слід використовувати [фільтрування запитів](./filter-queries.md) і подібні методи.
Використання has перевірок найкраще підходить для використання в [плагіні розмов](../plugins/conversations.md).

:::

has перевірки правильно звужують тип контексту.
Це означає, що перевірка наявності в контексті даних запиту зворотного виклику повідомить TypeScript, що в контексті присутнє поле `ctx.callbackQuery.data`.

```ts
if (ctx.hasCallbackQuery(/query-data-\d+/)) {
  // Тепер відомо, що поле `ctx.callbackQuery.data` присутнє
  const data: string = ctx.callbackQuery.data;
}
```

Те саме стосується всіх інших перевірок.
Перегляньте [довідку API про об’єкт контексту](https://deno.land/x/grammy/mod.ts?s=Context#method_has_0), щоб побачити список усіх has перевірок.
Також перегляньте статичну властивість `Context.has` у [довідці API](https://deno.land/x/grammy/mod.ts?s=Context#Static_Properties), яка дозволяє створювати ефективні предикатні функції для дослідження багатьох об'єктів контексту.

## Доступні дії

Якщо ви хочете відповісти на повідомлення від користувача, ви можете написати наступне:

```ts
bot.on("message", async (ctx) => {
  // Отримуємо ідентифікатор чату.
  const chatId = ctx.msg.chat.id;
  // Текст для відповіді.
  const text = "Я отримав твоє повідомлення!";
  // Надсилаємо відповідь.
  await bot.api.sendMessage(chatId, text);
});
```

Ви можете помітити дві речі, які не є оптимальними в цьому прикладі:

1. Ми повинні мати доступ до об’єкта `bot`.
   Це означає, що нам доведеться передавати обʼєкт `bot` по всій кодовій базі, щоб відповідати, що дратує, коли у вас більше одного вихідного файлу і ви визначаєте обробник десь в іншому місці.
2. Ми повинні вилучити ідентифікатор чату з контексту та знову явно передати його в `sendMessage`.
   Це теж дратує, тому що ви, швидше за все, завжди хочете відповідати тому самому користувачеві, який надіслав повідомлення.
   Уявіть, як часто ви вводите те саме знову і знову!

Щодо першого пункту об’єкт контексту просто надає вам доступ до того самого об’єкта API, який ви знайдете в `bot.api`, він називається `ctx.api`.
Тепер ви можете замість цього написати `ctx.api.sendMessage`, і вам більше не доведеться передавати об’єкт `bot`.
Зручно.

Однак справжня сила полягає у виправленні другого пункту.
Об’єкт контексту дозволяє просто надіслати відповідь так:

```ts
bot.on("message", async (ctx) => {
  await ctx.reply("Я отримав твоє повідомлення!");
});

// Або ще коротше:
bot.on("message", (ctx) => ctx.reply("Впіймав!"));
```

Лаконічно! :tada:

Під капотом контекст _вже знає свій ідентифікатор чату_: `ctx.msg.chat.id`, тому він дає вам метод `reply`, щоб надіслати повідомлення у той самий чат.
Всередині себе `reply` знову викликає `sendMessage` із попередньо заповненим для вас ідентифікатором чату.

Отже, усі методи об’єкта контексту приймають об’єкти параметрів типу `Other`, як пояснювалося [раніше](./basics.md#sending-messages).
Це можна використати для передачі подальших налаштувань кожному виклику API.

::: tip Функція відповіді Telegram
Незважаючи на те, що в grammY (та багатьох інших фреймворках) метод називається `ctx.reply`, він не використовує [функцію відповіді Telegram](https://telegram.org/blog/replies-mentions-hashtags#replies) де є посилання на попереднє повідомлення.

Якщо ви подивитеся у [довіднику Telegram Bot API](https://core.telegram.org/bots/api#sendmessage), що може робити `sendMessage`, ви побачите кілька параметрів: `parse_mode`, `disable_web_page_preview` і `reply_to_message_id`.
Останнє можна використати, щоб зробити повідомлення відповіддю:

```ts
await ctx.reply("^ Це повідомлення!", {
  reply_to_message_id: ctx.msg.message_id,
});
```

Той самий об’єкт параметрів можна передати в `bot.api.sendMessage` і `ctx.api.sendMessage`.
Використовуйте автодоповнення, щоб побачити доступні параметри прямо в редакторі коду.
:::

Звичайно, кожен інший метод у `ctx.api` має короткий метод із правильними попередньо заповненими значеннями: `ctx.replyWithPhoto`, щоб відповісти фотографією, або `ctx.exportChatInviteLink`, щоб отримати посилання для запрошення до відповідного чату.
Якщо ви хочете отримати загальне уявлення про те, які короткі методи існують, тоді автодоповнення стане вашим другом разом із [довідкою API grammY](https://deno.land/x/grammy/mod.ts?s=Context).

Можливо, вам не завжди потрібно реагувати в тому ж чаті.
У цьому випадку ви можете просто повернутися до використання методів `ctx.api` і вказати всі параметри під час їх виклику.
Наприклад, якщо ви отримали повідомлення від Аліси та хочете відреагувати, надіславши повідомлення Бобу, ви не можете використовувати `ctx.reply`, оскільки він завжди надсилатиме повідомлення до чату з Алісою.
Натомість викличте `ctx.api.sendMessage` і вкажіть ідентифікатор чату Боба.

## Як створюються об’єкти контексту

Щоразу, коли ваш бот отримує нове повідомлення від Telegram, воно загортається в об’єкт оновлення.
Насправді об’єкти оновлення можуть містити не лише нові повідомлення, а й усі інші речі, як-от редагування повідомлень, відповіді на опитування та [багато іншого](https://core.telegram.org/bots/api#update).

Новий об’єкт контексту створюється виключно один раз для кожного вхідного оновлення.
Контексти для різних оновлень абсолютно непов’язані об’єкти, вони лише посилаються на ту саму інформацію про бота через `ctx.me`.

Той самий об’єкт контексту для одного оновлення буде спільно використовуватися всіма встановленими на боті middlaware ([документація](./middleware.md)).

## Налаштування об’єкта контексту

> Якщо ви вперше знайомитеся з об’єктами контексту, вам не обовʼязково приділяти увагу решті цієї сторінки.

За бажанням ви можете встановити власні властивості в об’єкті контексту.

### Через middleware (рекомендовано)

Налаштування можна легко виконати в [middleware](./middleware.md).

::: tip Middle... що?
Цей розділ потребує розуміння middleware, тому, якщо ви ще не переходили до [розділу про middleware](./middleware.md), ось дуже короткий підсумок.

Все, що вам справді потрібно знати, це те, що кілька обробників можуть обробляти один обʼєкт контексту.
Існують спеціальні обробники, які можуть змінювати `ctx` перед запуском будь-яких інших обробників, і зміни першого обробника будуть видимі для всіх наступних обробників.
:::

Ідея полягає в тому, щоб встановити middleware перед реєстрацією інших обробників.
Потім ви можете встановити потрібні властивості в цих обробниках.
Якщо ви застосовуєте `ctx.yourCustomPropertyName = yourCustomValue` всередині такого обробника, то властивість `ctx.yourCustomPropertyName` також буде доступна в наступних обробниках.

Для ілюстрації припустімо, що ви хочете встановити властивість під назвою `ctx.config` для об’єкта контексту.
У цьому прикладі ми будемо використовувати його для збереження деяких налаштувань проєкту, щоб усі обробники мали до них доступ.
Налаштування полегшить виявлення того, ким використовується бот: його розробником чи звичайним користувачем.

Відразу після створення бота виконайте наступне:

```ts
const BOT_DEVELOPER = 123456; // ідентифікатор чату розробника бота

bot.use(async (ctx, next) => {
  // Змінюємо об’єкт контексту, встановивши налаштування.
  ctx.config = {
    botDeveloper: BOT_DEVELOPER,
    isDeveloper: ctx.from?.id === BOT_DEVELOPER,
  };
  // Запускаємо наступні обробники.
  await next();
});
```

Після цього ви можете використовувати `ctx.config` в інших обробниках.

```ts
bot.command("start", async (ctx) => {
  // Працюємо тут зі зміненим контекстом!
  if (ctx.config.isDeveloper) await ctx.reply("Привіт, ма!! <3");
  else await ctx.reply("Ласкаво просимо, людино!");
});
```

Однак ви помітите, що TypeScript не знає, що `ctx.config` доступний, навіть якщо ми призначаємо властивість правильно.
Таким чином, хоча код працюватиме під час виконання, він не скомпілюється.
Щоб виправити це, нам потрібно налаштувати тип контексту та додати властивість.

```ts
interface BotConfig {
  botDeveloper: number;
  isDeveloper: boolean;
}

type MyContext = Context & {
  config: BotConfig;
};
```

Новий тип `MyContext` тепер точно описує об’єкти контексту, які насправді обробляє наш бот.

> Вам необхідно забезпечувати синхронізацію типів із властивостями, які ви ініціалізуєте.

Ми можемо використовувати новий тип, передавши його в конструктор `Bot`.

```ts
const bot = new Bot<MyContext>("");
```

У підсумку налаштування виглядатимуть наступним чином:

<CodeGroup>
  <CodeGroupItem title="TypeScript" active>

```ts
const BOT_DEVELOPER = 123456; // ідентифікатор чату розробника бота

// Визначаємо власний тип контексту.
interface BotConfig {
  botDeveloper: number;
  isDeveloper: boolean;
}
type MyContext = Context & {
  config: BotConfig;
};

const bot = new Bot<MyContext>("");

// Встановлюємо настроювані властивості об’єктів контексту.
bot.use(async (ctx, next) => {
  ctx.config = {
    botDeveloper: BOT_DEVELOPER,
    isDeveloper: ctx.from?.id === BOT_DEVELOPER,
  };
  await next();
});

// Визначаємо обробника для налаштованих об’єктів контексту.
bot.command("start", async (ctx) => {
  if (ctx.config.isDeveloper) await ctx.reply("Привіт, ма!");
  else await ctx.reply("Ласкаво просимо");
});
```

</CodeGroupItem>
  <CodeGroupItem title="JavaScript">

```js
const BOT_DEVELOPER = 123456; // ідентифікатор чату розробника бота

const bot = new Bot("");

// Встановлюємо настроювані властивості об’єктів контексту.
bot.use(async (ctx, next) => {
  ctx.config = {
    botDeveloper: BOT_DEVELOPER,
    isDeveloper: ctx.from?.id === BOT_DEVELOPER,
  };
  await next();
});

// Визначаємо обробника для налаштованих об’єктів контексту.
bot.command("start", async (ctx) => {
  if (ctx.config.isDeveloper) await ctx.reply("Привіт, ма!");
  else await ctx.reply("Ласкаво просимо");
});
```

</CodeGroupItem>
</CodeGroup>

Звичайно, власний тип контексту також можна передати іншим речам, які обробляють middleware, наприклад [composer](https://deno.land/x/grammy/mod.ts?s=Composer).

```ts
const composer = new Composer<MyContext>();
```

Деякі плагіни також вимагатимуть передачі власного типу контексту, як-от плагін [маршрутизатор](../plugins/router.md) або плагін [інтерактивних меню](../plugins/menu.md).
Перегляньте їхню документацію, щоб дізнатися, як вони використовують власний тип контексту.
Ці типи називаються flavor, як описано [тут](#flavor-для-контексту).

### Через успадкування

Окрім встановлення власних властивостей об’єкта контексту, ви можете створити підклас класу `Context`.

```ts
class MyContext extends Context {
  // ...
}
```

Однак ми рекомендуємо вам налаштовувати об’єкт контексту [через middleware](#через-middleware-рекомендовано), оскільки він гнучкіший і краще працює, якщо ви хочете встановити плагіни.

Нумо дивитися, як використовувати власні класи для об’єктів контексту.

Під час створення свого бота ви можете передати власний конструктор контексту, який використовуватиметься для створення екземплярів об’єктів контексту.
Зауважте, що ваш клас має розширювати `Context`.

<CodeGroup>
  <CodeGroupItem title="TypeScript" active>

```ts
import { Bot, Context } from "grammy";
import type { Update, UserFromGetMe } from "@grammyjs/types";

// Визначаємо власний клас контексту.
class MyContext extends Context {
  // Встановлюємо деякі власні властивості.
  public readonly customProp: number;

  constructor(update: Update, api: Api, me: UserFromGetMe) {
    super(update, api, me);
    this.customProp = me.username.length * 42;
  }
}

// Передаємо конструктор спеціального класу контексту як параметр.
const bot = new Bot("<token>", {
  ContextConstructor: MyContext,
});

bot.on("message", (ctx) => {
  // `ctx` тепер має тип `MyContext`.
  const prop = ctx.customProp;
});

bot.start();
```

</CodeGroupItem>
  <CodeGroupItem title="JavaScript" active>

```ts
const { Bot, Context } = require("grammy");

// Визначаємо власний клас контексту.
class MyContext extends Context {
  // Встановлюємо деякі власні властивості.
  public readonly customProp;

  constructor(update, api, me) {
    super(update, api, me);
    this.customProp = me.username.length * 42;
  }
}

// Передаємо конструктор спеціального класу контексту як параметр.
const bot = new Bot("<token>", {
  ContextConstructor: MyContext,
});

bot.on("message", (ctx) => {
  // `ctx` тепер має тип `MyContext`.
  const prop = ctx.customProp;
});

bot.start();
```

</CodeGroupItem>
  <CodeGroupItem title="Deno">

```ts
import { Bot, Context } from "https://deno.land/x/grammy/mod.ts";
import type { Update, UserFromGetMe } from "https://esm.sh/@grammyjs/types";

// Визначаємо власний клас контексту.
class MyContext extends Context {
  // Встановлюємо деякі власні властивості.
  public readonly customProp: number;

  constructor(update: Update, api: Api, me: UserFromGetMe) {
    super(update, api, me);
    this.customProp = me.username.length * 42;
  }
}

// Передаємо конструктор спеціального класу контексту як параметр.
const bot = new Bot("<token>", {
  ContextConstructor: MyContext,
});

bot.on("message", (ctx) => {
  // `ctx` тепер має тип `MyContext`.
  const prop = ctx.customProp;
});

bot.start();
```

</CodeGroupItem>
</CodeGroup>

Зверніть увагу на те, як власний тип контексту буде виведено автоматично, коли ви використовуєте підклас.
Вам більше не потрібно писати `Bot<MyContext>`, оскільки ви вже вказали свій конструктор підкласу в об’єкті параметрів `new Bot()`.

Однак це дуже ускладнює, якщо не унеможливлює, встановлення плагінів, оскільки для них часто потрібно встановлювати flavor для контексту.

## Flavor для контексту

Flavor це спосіб повідомити TypeScript про нові властивості вашого об’єкта контексту.
Ці нові властивості можна постачати в плагінах або інших модулях, а потім встановити у вашому боті.

Flavor для контексту також може перетворювати типи існуючих властивостей за допомогою автоматичних процедур, які визначаються плагінами.

### Додаючий flavor

Як було зазначено вище, існує два різних типи flavor.
Основний називається _додаючий flavor_, і щоразу, коли ми говоримо про flavor для контексту, ми маємо на увазі саме цей тип.
Давайте подивимося, як це працює.

Наприклад, якщо у вас є [дані сеансу](../plugins/session.md), ви повинні зареєструвати `ctx.session` для типу контексту.
Інакше:

1. ви не зможете встановити вбудований плагін сеансів,
2. у вас не буде доступу до `ctx.session` у ваших обробниках.

> Незважаючи на те, що ми використовуємо сесії як приклад, подібні речі застосовуються до багатьох інших випадків.
> Насправді більшість плагінів нададуть вам flavor, який вам потрібно використовувати.

Flavor для контексту це просто невеликий новий тип, який визначає властивості, які слід додати до типу контексту.
Давайте розглянемо приклад flavor.

```ts
interface SessionFlavor<S> {
  session: S;
}
```

Тип `SessionFlavor` ([довідка API](https://deno.land/x/grammy/mod.ts?s=SessionFlavor)) простий: він визначає лише властивість `session`.
Він приймає параметр типу, який визначатиме фактичну структуру даних сеансу.

Чим це корисно?
Ось як ви можете розширити свій контекст за допомогою даних сеансу:

```ts
import { Context, SessionFlavor } from "grammy";

// Оголошуємо `ctx.session` типу `string`.
type MyContext = Context & SessionFlavor<string>;
```

Тепер ви можете використовувати плагін сесії та мати доступ до `ctx.session`:

```ts
bot.on("message", (ctx) => {
  // Тепер `str` має тип `string`.
  const str = ctx.session;
});
```

### Перетворюючий flavor

Інший тип flavor є більш потужним.
Замість встановлення за допомогою оператора `&`, їх потрібно встановити так:

```ts
import { Context } from "grammy";
import { SomeFlavorA } from "my-plugin";

type MyContext = SomeFlavorA<Context>;
```

Все інше працює так само.

Кожен офіційний плагін зазначає у своїй документації, чи має він використовуватися через додаючий або перетворюючий flavor.

### Поєднання різних flavor

Якщо у вас є різні [додаючі flavor](#додаючий-flavor), ви можете просто встановити їх наступним чином:

```ts
type MyContext = Context & FlavorA & FlavorB & FlavorC;
```

Порядок встановлення додаючих flavor не має значення, ви можете комбінувати їх як вам заманеться.

Кілька [перетворюючих flavor](#перетворюючий-flavor) також можна комбінувати:

```ts
type MyContext = FlavorX<FlavorY<FlavorZ<Context>>>;
```

Тут порядок може мати значення, оскільки спочатку `Context` буде перетворено `FlavorZ`, потім `FlavorY`, і результат цього буде знову перетворено вже `FlavorX`.

Ви навіть можете змішувати додаючі та перетворюючі flavor:

```ts
type MyContext = FlavorX<
  FlavorY<
    FlavorZ<
      Context & FlavorA & FlavorB & FlavorC
    >
  >
>;
```

Обов’язково дотримуйтеся цього шаблону під час встановлення кількох плагінів.
Існує ряд помилок типів, які виникають через неправильне поєднання декількох flavor.
