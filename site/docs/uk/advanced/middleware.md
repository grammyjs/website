---
prev: ./
next: ./structuring.md
---

# Спрощення middleware

У посібнику [ми представили middleware](../guide/middleware.md) як стек функцій.
Хоча це не неправильно, що ви можете використовувати middleware таким лінійним способом, що стосується не тільки grammY; назвати його просто стеком є спрощенням.

## Middleware у grammY

Зазвичай ви бачите наступний шаблон.

```ts
const bot = new Bot("<токен>");

bot.use(/* ... */);
bot.use(/* ... */);

bot.on(/* ... */);
bot.on(/* ... */);
bot.on(/* ... */);

bot.start();
```

Виглядає дуже схоже на стек, за винятком того, що за кулісами це насправді дерево.
Серцем цієї функціональсті є клас `Composer` ([довідка](https://deno.land/x/grammy/mod.ts?s=Composer)), який будує це дерево.

Найперше кожен екземпляр `Bot` є екземпляром `Composer`.
Це лише підклас, тому `class Bot extends Composer`.

Крім того, ви повинні знати, що кожен окремий метод `Composer` внутрішньо викликає `use`.
Наприклад, `filter` просто викликає `use` з деяким розгалуженням middleware, тоді як `on` просто знову викликає `filter` з деякою предикатною функцією, яка відповідає оновленням відповідному [запиту фільтрування](../guide/filter-queries.md).
Тому наразі ми можемо обмежитися розглядом `use`, а решта піде саме з нього.

Тепер ми маємо трохи зануритися в деталі того, що `Composer` робить з вашими викликами `use`, і чим він відрізняється від інших систем middleware.
Різниця може здатися незначною, але зачекайте до наступного підрозділу, щоб дізнатися, чому вона має чудові наслідки.

## Збільшення можливостей `Composer`

Ви можете інсталювати більше middleware на екземпляр `Composer` навіть після встановлення десь самого `Composer`.

```ts
const bot = new Bot("<токен>"); // підклас класу `Composer`

const composer = new Composer();
bot.use(composer);

// Вони виконуватимуться:
composer.use(/* A */);
composer.use(/* B */);
composer.use(/* C */);
```

`A`, `B` і `C` будуть запущені.
Усе це говорить про те, що як тільки ви встановили екземпляр `Composer`, ви все ще можете викликати `use` на ньому, і ці middleware все одно працюватимуть.
У цьому немає нічого вражаючого, але це вже головна відмінність від популярних конкуруючих фреймворків, які просто ігнорують наступні операції.

Вам може бути цікаво, де тут розташована структура дерева.
Давайте подивимося на цей фрагмент:

```ts
const composer = new Composer();

composer.use(/* A */);
composer.use(/* B */).use(/* C */);
composer.use(/* D */).use(/* E */).use(/* F */).use(/* G */);
composer.use(/* H */).use(/* I */);
composer.use(/* J */).use(/* K */).use(/* L */);
```

Ви бачите це?

Як ви можете здогадатися, всі middleware буде запущено в порядку від `A` до `L`.

Інші бібліотеки внутрішньо зрівнюють цей код, щоб він був еквівалентним `composer.use(/* A */).use(/* B */).use(/* C */).use(/* D */)...` і так далі.
Навпаки, grammY зберігає вказане вами дерево: один кореневий вузол `composer` має п’ять дочірніх елементів: `A`, `B`, `D`, `H`, `J`, а дочірній `B` має ще один дочірній елемент: `C`.
Потім це дерево буде проходити кожне оновлення в глибинному порядку, отже фактично проходячи від `A` до `L` у лінійному порядку, подібно до того, що ви знаєте з інших систем.

Це стає можливим завдяки створенню нового екземпляра `Composer` кожного разу, коли ви викликаєте `use`, який у свою чергу буде розширено, як пояснено вище.

## Конкатенація викликів `use`

Якби ми використовували лише `use`, це було б не надто корисним.
Стає цікавіше, як тільки, наприклад, `filter` вступає в дію.

Гляньте:

```ts
const composer = new Composer();

composer.filter(/* 1 */, /* A */).use(/* B */)

composer.filter(/* 2 */).use(/* C */, /* D */)
```

У 3-му рядку ми реєструємо `A` за предикатною функцією `1`.
`A` буде оцінюватися лише для оновлень, які відповідають умові `1`.
Однак `filter` повертає екземпляр `Composer`, який ми доповнюємо викликом `use` у 3-му рядку, тому `B` все ще перекривається умовою `1`, навіть якщо його встановлено в зовсім іншому виклику `use`.

5-й рядок еквівалентний 3-му рядку у тому відношенні, що і `C`, і `D` виконуватимуться, лише якщо виконується `2`.

Пам’ятаєте, як виклики `bot.on()` можна об’єднувати, щоб об’єднати запити фільтрування за допомогою логічної операції І?
Уявіть це:

```ts
const composer = new Composer();

composer.filter(/* 1 */).filter(/* 2 */).use(/* A */);
```

`2` перевірятиметься, лише якщо виконується `1`, а `A` запускатиметься, лише якщо виконується `2`, отже й `1`.

Перегляньте розділ про [поєднання кількох запитів фільтрування](../guide/filter-queries.md#поєднання-кількох-запитів) зі своїми новими знаннями та відчуйте свою нову силу.

Особливим випадком тут є `fork`, оскільки він запускає два одночасних обчислення, тобто які чергуються в event loop.
Замість повернення екземпляра `Composer`, створеного базовим викликом `use`, він повертає `Composer`, який відображає розгалужене обчислення.
Це дозволяє створювати короткі шаблони: наприклад, `bot.fork().on(":text").use(/* A */)`.
`A` тепер виконуватиметься на гілці паралельних обчислень.
