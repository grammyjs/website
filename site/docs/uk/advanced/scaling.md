---
prev: ./structuring.md
next: ./reliability.md
---

# Масштабування II: високе навантаження

Здатність вашого бота справлятися з високим навантаженням залежить від того, як ви запускаєте бота: [через тривале опитування чи через вебхуки](../guide/deployment-types.md).
У будь-якому випадку, вам варто прочитати про деякі підводні камені [нижче](#%D0%BF%D0%B0%D1%80%D0%B0%D0%BB%D0%B5%D0%BB%D1%96%D0%B7%D0%BC-%D0%B2%D0%B0%D0%B6%D0%BA%D0%B8%D0%B8).

## Тривале опитування

Більшості ботів ніколи не потрібно обробляти більше кількох повідомлень на хвилину під час "пікового навантаження".
Іншими словами, масштабованість їх не турбує.
Щоб бути передбачуваним, grammY обробляє оновлення послідовно.
Ось порядок дій:

1. Отримати до 100 оновлень за допомогою `getUpdates` ([довідка Telegram Bot API](https://core.telegram.org/bots/api#getupdates)).
2. Для кожного оновлення дочекатися (`await`) виконання стеку middleware.

Проте, якщо ваш бот обробляє одне повідомлення в секунду або щось близко того під час пікових навантажень, це може почати негативно впливати на швидкість відгуку.
Наприклад, повідомлення Боба має зачекати, поки повідомлення Аліси не буде оброблено.

Цю проблему можна вирішити, не чекаючи на завершення обробки повідомлення Аліси, тобто обробляючи обидва повідомлення одночасно.
Щоб досягти максимальної оперативності, ми також хотіли б підтягувати нові повідомлення, поки повідомлення Боба та Аліси ще обробляються.
В ідеалі, ми також хотіли б обмежити одночасність деяким фіксованим числом, щоб обмежити максимальне навантаження на сервер.

Паралельна обробка не входить до базового пакету grammy.
Замість цього, для запуску вашого бота **може бути використаний пакет [плагіну для конкурентності (runner)](../plugins/runner.md)**.
Він підтримує все вищезазначене "з коробки" і надзвичайно простий у використанні.

```ts
// Раніше
bot.start();

// За допомогою плагіну, який експортує `run`.
run(bot);
```

За замовчуванням ліміт паралельності складає 500.
Якщо ви хочете глибше вивчити пакет, перегляньте цю [сторінку](../plugins/runner.md).

Паралелізм - це складно, тому перегляньте [підрозділ нижче](#%D0%BF%D0%B0%D1%80%D0%B0%D0%BB%D0%B5%D0%BB%D1%96%D0%B7%D0%BC-%D0%B2%D0%B0%D0%B6%D0%BA%D0%B8%D0%B8), щоб дізнатися, про що слід пам'ятати при використанні цього плагіну.

## Вебхуки

Якщо ви запустите бота на вебхуках, він автоматично оброблятиме оновлення паралельно, щойно вони надходитимуть.
Звичайно, для того, щоб це добре працювало під високим навантаженням, вам слід ознайомитися з [використанням вебхуків](../guide/deployment-types.md#як-використовувати-вебхуки).
Це означає, що ви все одно повинні знати про деякі наслідки паралелізму, зверніть увагу на [підрозділ нижче](#%D0%BF%D0%B0%D1%80%D0%B0%D0%BB%D0%B5%D0%BB%D1%96%D0%B7%D0%BC-%D0%B2%D0%B0%D0%B6%D0%BA%D0%B8%D0%B8).

Також [пам'ятайте](../guide/deployment-types.md#своєчасне-завершення-запитів-вебхуків), що Telegram буде доставляти оновлення з одного чату послідовно, але оновлення з різних чатів одночасно.

## Паралелізм важкий

Якщо ваш бот обробляє всі оновлення одночасно, це може спричинити низку проблем, які потребують особливої уваги.
Наприклад, якщо два повідомлення з одного чату будуть отримані одним викликом `getUpdates`, вони будуть оброблені одночасно.
Порядок повідомлень в одному чаті більше не гарантується.

Основним місцем, де це може призвести до конфлікту, є використання [сесій](../plugins/session.md), що може спричинити конфлікт запису після читання.
Уявіть собі таку послідовність подій:

1. Аліса надсилає повідомлення A.
2. Бот починає обробку A.
3. Бот зчитує дані сесії для Аліси з бази даних.
4. Аліса надсилає повідомлення B.
5. Бот починає обробку B.
6. Бот зчитує дані сесії для Аліси з бази даних.
7. Бот завершує обробку A і записує нову сесію в базу даних.
8. Бот завершує обробку B і записує нову сесію в базу даних, тим самим перезаписуючи зміни, зроблені під час обробки A.
   Втрата даних через конфлікт запису після читання!

> Примітка: ви можете спробувати використовувати транзакції бази даних для ваших сеансів, але тоді ви зможете лише виявити конфлікт, а не запобігти йому.
> Спроба використати блокування натомість ефективно усуне весь паралелізм.
> Набагато легше уникнути конфклікта в першу чергу.

Більшість інших сесійних систем серверних фреймворків просто приймають ризик станів гонок, оскільки вони трапляються не надто часто в Інтернеті.
Однак ми не хочемо цього, тому що боти Telegram набагато частіше стикаються із зіткненнями паралельних запитів на один і той самий ключ сеансу.
Отже, ми повинні переконатися, що оновлення, які отримують доступ до одних і тих же даних сеансу, обробляються послідовно, щоб уникнути цього небезпечного стану гонки.

Плагін для конкурентності (runner) постачається з middleware `sequentialize()`, який гарантує, що оновлення, які конфліктують, обробляються послідовно.
Ви можете налаштувати його за допомогою тієї самої функції, яку ви використовуєте для визначення ключа сеансу.
Тоді він уникне вищезгаданого стану гонки, сповільнивши ті й тільки ті оновлення, які могли б спричинити колізію.

<CodeGroup>
  <CodeGroupItem title="TypeScript" active>

```ts
import { Bot, Context, session } from "grammy";
import { run, sequentialize } from "@grammyjs/runner";

// Створюємо бота.
const bot = new Bot("");

// Створюємо унікальний ідентифікатор для об'єкту `Context`.
function getSessionKey(ctx: Context) {
  return ctx.chat?.id.toString();
}

// Упорядкуємо дані перед доступом до даних сеансу!
bot.use(sequentialize(getSessionKey));
bot.use(session({ getSessionKey }));

// Додаємо звичайний middleware, тепер з підтримкою безпечних сеансів.
bot.on("message", (ctx) => ctx.reply("Отримав ваше повідомлення."));

// Все одно запускаємо бота паралельно!
run(bot);
```

</CodeGroupItem>

<CodeGroupItem title="JavaScript">

```ts
const { Bot, Context, session } = require("grammy");
const { run, sequentialize } = require("@grammyjs/runner");

// Створюємо бота.
const bot = new Bot("");

// Створюємо унікальний ідентифікатор для об'єкту `Context`.
function getSessionKey(ctx) {
  return ctx.chat?.id.toString();
}

// Упорядкуємо дані перед доступом до даних сеансу!
bot.use(sequentialize(getSessionKey));
bot.use(session({ getSessionKey }));

// Додаємо звичайний middleware, тепер з підтримкою безпечних сеансів.
bot.on("message", (ctx) => ctx.reply("Отримав ваше повідомлення."));

// Все одно запускаємо бота паралельно!
run(bot);
```

</CodeGroupItem>
 <CodeGroupItem title="Deno">

```ts
import { Bot, Context, session } from "https://deno.land/x/grammy/mod.ts";
import { run, sequentialize } from "https://deno.land/x/grammy_runner/mod.ts";

// Створюємо бота.
const bot = new Bot("");

// Створюємо унікальний ідентифікатор для об'єкту `Context`.
function getSessionKey(ctx: Context) {
  return ctx.chat?.id.toString();
}

// Упорядкуємо дані перед доступом до даних сеансу!
bot.use(sequentialize(getSessionKey));
bot.use(session({ getSessionKey }));

// Додаємо звичайний middleware, тепер з підтримкою безпечних сеансів.
bot.on("message", (ctx) => ctx.reply("Отримав ваше повідомлення."));

// Все одно запускаємо бота паралельно!
run(bot);
```

</CodeGroupItem>
</CodeGroup>

Приєднуйтесь до [чату Telegram](https://t.me/grammyjs), щоб обговорити, як використовувати плагін для конкурентності (runner) з вашим ботом.
Ми завжди раді почути відгук від людей, які підтримують великих ботів, щоб ми могли покращити grammY на основі їхнього досвіду роботи з пакетом.
