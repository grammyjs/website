# Конкурентність (`runner`)

Цей пакет можна використовувати, якщо ви запускаєте бота [використовуючи тривале опитування](../guide/deployment-types.md) та хочете, щоб повідомлення оброблялися паралельно.

> Переконайтеся, що ви розумієте [2-й етап масштабування](../advanced/scaling.md#тривале-опитування), перш ніж використовувати runner.

## Навіщо потрібен runner

Якщо ви розміщуєте бота використовуючи тривале опитування та хочете його масштабувати, не можна обійтися без паралельної обробки оновлень, оскільки послідовна обробка оновлень відбувається надто повільно.
Унаслідок цього боти стикаються з низкою проблем.

- Чи існують умови гонки?
- Чи можемо ми все ще чекати (`await`) виконання стеку middleware? Ми мусимо знати це для обробки помилок!
- Що робити, якщо middleware з якихось причин ніколи не виконається; чи заблокує це бота?
- Чи можемо ми обмежити навантаження на сервер?

Як бачите, нам потрібне рішення, яке може вирішити всі перераховані вище проблеми, щоб досягти належного тривалого опитування для бота.
Це проблема, яка дуже відрізняється від написання middleware або надсилання повідомлень у Telegram.
Отже, вона не вирішується за допомогою базового пакету grammY.
Замість цього ви можете використовувати [runner](https://github.com/grammyjs/runner).
Він також має власну [довідку API](https://deno.land/x/grammy_runner/mod.ts).

## Використання

Ось простий приклад.

<CodeGroup>
  <CodeGroupItem title="TypeScript" active>

```ts
import { Bot } from "grammy";
import { run } from "@grammyjs/runner";

// Створюємо бота.
const bot = new Bot("");

// Додаємо звичайний middleware тощо
bot.on("message", (ctx) => ctx.reply("Got your message."));

// Запускаємо бота паралельно!
run(bot);
```

</CodeGroupItem>
 <CodeGroupItem title="JavaScript">

```ts
const { Bot } = require("grammy");
const { run } = require("@grammyjs/runner");

// Створюємо бота.
const bot = new Bot("");

// Додаємо звичайний middleware тощо
bot.on("message", (ctx) => ctx.reply("Отримав ваше повідомлення."));

// Запускаємо бота паралельно!
run(bot);
```

</CodeGroupItem>
 <CodeGroupItem title="Deno">

```ts
import { Bot } from "https://deno.land/x/grammy/mod.ts";
import { run } from "https://deno.land/x/grammy_runner/mod.ts";

// Створюємо бота.
const bot = new Bot("");

// Додаємо звичайний middleware тощо
bot.on("message", (ctx) => ctx.reply("Отримав ваше повідомлення."));

// Запускаємо бота паралельно!
run(bot);
```

</CodeGroupItem>
</CodeGroup>

Авжеж під капотом багато чого відбувається, хоча це й виглядає дуже просто.

## Як це працює за кулісами

Кожен runner складається з трьох різних частин.

1. **Джерело** підтягує оновлення з Telegram.
2. **Поглинач** надає оновлення екземпляру бота.
3. Компонент **runner** зʼєднує джерело і поглинач, а також дозволяє запускати і зупиняти бота.

```asciiart:no-line-numbers
api.telegram.org <—> джерело <—> runner <—> поглинач <—> бот
```

### Джерело

Runner постачається з одним джерелом за замовчуванням, яке може працювати з будь-яким `UpdateSupplier` ([довідка API](https://deno.land/x/grammy_runner/mod.ts?s=UpdateSupplier)).
Такий постачальник оновлень легко створити з екземпляра бота.
Якщо ви хочете створити його самостійно, обовʼязково ознайомтеся з `createUpdateFetcher` ([довідка API](https://deno.land/x/grammy_runner/mod.ts?s=createUpdateFetcher)).

Джерело - це асинхронний ітератор пакетів оновлень, але він може бути активним або неактивним і ви можете закрити (`close`) його, щоб відʼєднатися від серверів Telegram.

### Поглинач

Runner постачається з трьома можливими реалізаціями поглинача: послідовною, у якої поведінка така сама, як у `bot.start()`, пакетною, яка переважно корисна для зворотної сумісності з іншими фреймворками, та повністю паралельною, яка використовується у методі `run`.
Всі вони працюють з обʼєктами `UpdateConsumer` ([довідка API](https://deno.land/x/grammy_runner/mod.ts?s=UpdateConsumer)), які легко створити з екземпляра бота.
Якщо ви хочете створити його самостійно, обовʼязково перегляньте `handleUpdate` на екземплярі класу `Bot` ([довідка API](https://deno.land/x/grammy/mod.ts?s=Bot#method_handleUpdate_0)).

Поглинач містить чергу ([довідка API](https://deno.land/x/grammy_runner/mod.ts?s=DecayingDeque)) окремих оновлень, які наразі обробляються.
Додавання нових оновлень до черги негайно змусить поглинача оновлень обробити їх і повернути `Promise`, який вирішиться, як тільки в черзі знову зʼявиться вільне місце.
Розвʼязане інтегральне число визначає вільний простір.
Отже, runner дотримується обмеження на паралельну обробку через екземпляр черги, що лежить в основі.

Черга також викидає оновлення, обробка яких займає занадто багато часу; ви можете вказати `timeoutHandler` при створенні відповідного поглинача.
Звісно, при створенні поглинача також слід передбачити обробник помилок.

Якщо ви використовуєте `run(bot)`, буде використано обробник помилок з `bot.catch`.

### Runner

Runner - це звичайний цикл, який витягує оновлення з джерела та надає їх поглиначу.
Як тільки у поглинача знову зʼявиться вільне місце, runner отримає наступну порцію оновлень з джерела.

Коли ви створюєте runner за допомогою `createRunner` ([довідка API](https://deno.land/x/grammy_runner/mod.ts?s=createRunner)), ви отримуєте обʼєкт, який можна використовувати для керування runner'ом.
Наприклад, ви можете запускати і зупиняти його або отримувати `Promise`, який виконується у разі зупинки runner'а.
Цей обʼєкт також повертається методом `run`.
Ознайомтеся з [довідкою API](https://deno.land/x/grammy_runner/mod.ts?s=RunnerHandle) обʼєкта `RunnerHandle`.

## Послідовна обробка там, де це необхідно

Швидше за все, ви хочете бути впевненими, що повідомлення з одного чату будуть оброблятися послідовно.
Це корисно при встановленні [middleware сесії](./session.md), але це також гарантує, що ваш бот не переплутає порядок повідомлень в одному чаті.

Runner експортує middleware `sequentialize`, який піклується про це.
Ви можете переглянути цей [розділ](../advanced/scaling.md#паралелізм-важкии), щоб дізнатися, як ним користуватися.

Зараз ми розглянемо більш просунуте використання плагіна.

Функція обмеження, що постачається з плагіном, може бути використана не лише для визначення ідентифікатора чату або ідентифікатора користувача.
Замість цього ви можете повернути _список рядків ідентифікаторів обмежень_, які окремо для кожного оновлення визначають, на які ще обчислення воно має зачекати, перш ніж почне обробку.

Наприклад, ви можете повернути ідентифікатор чату й ідентифікатор користувача автора повідомлення.

```ts
bot.use(sequentialize((ctx) => {
  const chat = ctx.chat?.id.toString();
  const user = ctx.from?.id.toString();
  return [chat, user].filter((con) => con !== undefined);
}));
```

Це гарантує, що повідомлення в одному чаті будуть впорядковані правильно.
Крім того, якщо Аліса надсилає повідомлення в групі, а потім надсилає повідомлення вашому боту в приватному чаті, то ці два повідомлення будуть впорядковані правильно.

У певному сенсі, ви можете задати граф залежностей між оновленнями.
Runner вирішить всі необхідні обмеження на льоту і заблокує ці оновлення до тих пір, поки це буде необхідно для забезпечення правильної послідовності повідомлень.

Реалізація цього дуже ефективна.
Вона потребує постійної (constant) памʼяті, якщо ви не вкажете нескінченний паралелізм, та сталого часу на обробку кожного оновлення.

## Graceful shutdown

Для того, щоб бот коректно завершив свою роботу, ви [повинні повідомити](../advanced/reliability.md#використовуючи-плагін-для-конкурентості-runner) йому, щоб він зупинився, коли процес наближається до завершення.

## Загальні відомості про плагін

- Назва: `runner`
- Джерело: <https://github.com/grammyjs/runner>
- Довідка: <https://deno.land/x/grammy_runner/mod.ts>
