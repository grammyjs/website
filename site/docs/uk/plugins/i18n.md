---
prev: false
next: false
---

# Інтернаціоналізація (`i18n`)

Плагін інтернаціоналізації дозволяє вашому боту розмовляти кількома мовами.

::: tip Не плутайте
Не плутайте це з [fluent](./fluent).

Цей плагін є покращеною версією [fluent](./fluent), яка працює на Deno та Node.js.
:::

## Пояснення інтернаціоналізації

> У цьому розділі пояснюється, що таке інтернаціоналізація, навіщо вона потрібна, що в ній складного, як вона повʼязана з локалізацією й навіщо для всього цього потрібен плагін.
> Якщо ви вже знаєте це, прокрутіть до [початку роботи](#початок-роботи).

По-перше, "internationalization" --- дуже довге слово.
Тому люди полюбляють писати першу й останню літеру: "i" та "n" відповідно.
Потім вони рахують усі літери, що залишилися: "nternationalizatio" (18 літер), і ставлять це число між "i" та "n", отримуючи в результаті _i18n_.
Не питайте нас чому.
Отже, i18n --- це просто дивна абревіатура слова "internationalization" (інтернаціоналізація).

Те саме робиться зі словом "localization" (локалізація), яке перетворюється на _l10n_.

### Що таке локалізація?

Локалізація означає створення бота, який може розмовляти кількома мовами.
Він повинен автоматично підлаштовувати свою мову під мову користувача.

Локалізувати потрібно не лише мову.
Ви також можете врахувати культурні відмінності або інші стандарти: наприклад, формати дати й часу.
Ось ще кілька прикладів речей, які відрізняються у різних країнах світу:

1. Дати
2. Час
3. Числа
4. Одиниці вимірювання
5. Множинність
6. Статі
7. Переноси
8. Великі літери
9. Вирівнювання
10. Символи та іконки
11. Сортування

... [тощо](https://youtu.be/0j74jcxSunY).

Всі ці речі разом визначають _локаль_ користувача.
Локалі часто отримують двобуквені коди: наприклад, `en` для англійської, `de` для німецької, `uk` для української тощо.
Якщо ви хочете дізнатися код вашої локалі, перегляньте цей [список](https://en.wikipedia.org/wiki/IETF_language_tag#List_of_common_primary_language_subtags).

### Що таке інтернаціоналізація?

У двох словах, інтернаціоналізація означає написання коду, який може підлаштовуватися під локаль користувача.
Інакше кажучи, інтернаціоналізація --- це те, що дозволяє здійснювати локалізацію (дивіться [вище](#що-таке-локалізація)).
Це означає, що хоча ваш бот фактично працює однаково для всіх, конкретні повідомлення, які він надсилає, відрізняються від користувача до користувача, тому бот може розмовляти різними мовами.

Ви здійснюєте інтернаціоналізацію, якщо не жорстко прописуєте в коді тексти, які надсилає ваш бот, а динамічно зчитуєте їх з файлу.
Ви здійснюєте інтернаціоналізацію, якщо не жорстко прописуєте в коді спосіб представлення дат і часу, а використовуєте бібліотеку, яка адаптує ці значення відповідно до різних стандартів.
Ви зрозуміли ідею: не варто жорстко прописувати в коді те, що має змінюватися залежно від місця проживання користувача або мови, якою він розмовляє.

### Навіщо потрібен цей плагін?

Цей плагін може допомогти вам протягом усього процесу інтернаціоналізації.
Він базується на [Fluent](https://projectfluent.org/) --- системі локалізації від [Mozilla](https://mozilla.org/en-US/).
Ця система має дуже потужний і вишуканий синтаксис, який дозволяє ефективно створювати переклади з природнім звучанням.

По суті, ви можете витягти те, що має адаптуватися до локалі користувача, у текстові файли, які ви додаєте до вашого коду.
Потім ви можете використовувати цей плагін для завантаження цих локалізацій.
Плагін автоматично визначить локаль користувача та вибере для вашого бота правильну мову для спілкування.

Нижче ми будемо називати ці текстові файли _файлами перекладу_.
Вони повинні відповідати синтаксису Fluent.

## Початок роботи

> У цьому розділі описано, як налаштувати структуру вашого проєкту і де зберігати файли перекладу.
> Якщо ви знайомі з цим, [пропустіть цей розділ](#використання), щоб дізнатися, як встановити і використовувати плагін.

Існує [кілька способів](#додавання-перекладів) додати більше мов до вашого бота.
Найпростіший спосіб --- створити каталог з файлами перекладів для Fluent.
Зазвичай цей каталог називається `locales/`.
Файли перекладу повинні мати розширення `.ftl` (fluent).

Ось приклад структури проєкту:

```asciiart:no-line-numbers
.
├── bot.ts
└── locales/
    ├── de.ftl
    ├── en.ftl
    ├── it.ftl
    └── uk.ftl
```

Якщо ви не знайомі з синтаксисом Fluent, ви можете прочитати їхній посібник: <https://projectfluent.org/fluent/guide>

Ось приклад файлу перекладу для української мови, який називається `locales/uk.ftl`:

```ftl
start = Привіт, чим я можу вам допомогти (/help)?
help =
    Надішліть мені текст, і я зроблю його жирним для вас.
    Ви можете змінити мою мову за допомогою команди /language.
```

Англійський еквівалент називатиметься `locales/en.ftl` і виглядатиме наступним чином:

```ftl
start = Hi, how can I /help you?
help =
    Send me some text, and I can make it bold for you.
    You can change my language using the /language command.
```

Тепер ви можете використовувати ці переклади у своєму боті за допомогою плагіна.
Він зробить їх доступними через `ctx.t`:

```ts
bot.command("start", async (ctx) => {
  await ctx.reply(ctx.t("start"));
});

bot.command("help", async (ctx) => {
  await ctx.reply(ctx.t("help"));
});
```

Щоразу, коли ви викликаєте `ctx.t`, локаль поточного обʼєкта контексту `ctx` використовується для пошуку правильного перекладу.
Пошук правильного перекладу здійснюється за допомогою _узгоджувача локалі_.
У найпростішому випадку він просто повертає `ctx.from.language_code`.

У результаті користувачі з різними локалями зможуть читати повідомлення кожен своєю мовою.

## Використання

Плагін визначає локаль користувача з багатьох різних факторів.
Одним з них є `ctx.from.language_code`, який буде надано клієнтом користувача.

Однак, існує багато інших способів визначення локалі користувача.
Наприклад, ви можете зберігати локаль користувача у вашій [сесії](./session).
Отже, існує два основних способи використання цього плагіна: [з сесіями](#з-сесіями) та [без сесій](#без-сесіи).

### Без сесій

Плагін простіше використовувати і налаштовувати без сесій.
Його основним недоліком буде те, що ви не зможете зберігати мови, які обирають користувачі.

Як було сказано вище, локаль, яка буде використовуватися для користувача, буде визначатися за допомогою `ctx.from.language_code`, який надходить від клієнта користувача.
Але якщо у вас немає перекладу цієї мови, буде використано мову за замовчуванням.
Іноді ваш бот може не бачити бажану мову користувача, надану його клієнтом, тому в цьому випадку також буде використано мову за замовчуванням.

**`ctx.from.language_code` буде доступним лише в тому випадку, якщо користувач раніше починав приватну розмову з вашим ботом.**

::: code-group

```ts [TypeScript]
import { Bot, Context } from "grammy";
import { I18n, I18nFlavor } from "@grammyjs/i18n";

// Для підтримки TypeScript та автодоповнення
// розширимо контекст за допомогою розширювача для контексту з плагіну i18n:
type MyContext = Context & I18nFlavor;

// Створюємо бота, як ми зазвичай це робимо.
// Не забуваємо розширити контекст.
const bot = new Bot<MyContext>("");

// Створюємо екземпляр`I18n`.
// Продовжуйте читати, щоб дізнатися, як налаштувати екземпляр.
const i18n = new I18n<MyContext>({
  defaultLocale: "uk", // дивіться нижче для отримання додаткової інформації
  directory: "locales", // завантажуємо всі файли перекладу з каталогу locales/
});

// Нарешті, реєструємо екземпляр i18n у боті,
// щоб повідомлення перекладалися!
bot.use(i18n);

// Зараз все налаштовано.
// Можемо отримати доступ до перекладів за допомогою `t` або `translate`.
bot.command("start", async (ctx) => {
  await ctx.reply(ctx.t("start-msg"));
});
```

```js [JavaScript]
const { Bot } = require("grammy");
const { I18n } = require("@grammyjs/i18n");

// Створюємо бота, як ми зазвичай це робимо.
const bot = new Bot("");

// Створюємо екземпляр`I18n`.
// Продовжуйте читати, щоб дізнатися, як налаштувати екземпляр.
const i18n = new I18n({
  defaultLocale: "uk", // дивіться нижче для отримання додаткової інформації
  directory: "locales", // завантажуємо всі файли перекладу з каталогу locales/
});

// Нарешті, реєструємо екземпляр i18n у боті,
// щоб повідомлення перекладалися!
bot.use(i18n);

// Зараз все налаштовано.
// Можемо отримати доступ до перекладів за допомогою `t` або `translate`.
bot.command("start", async (ctx) => {
  await ctx.reply(ctx.t("start-msg"));
});
```

```ts [Deno]
import { Bot, Context } from "https://deno.land/x/grammy/mod.ts";
import { I18n, I18nFlavor } from "https://deno.land/x/grammy_i18n/mod.ts";

// Для підтримки TypeScript та автодоповнення
// розширимо контекст за допомогою розширювача для контексту з плагіну i18n:
type MyContext = Context & I18nFlavor;

// Створюємо бота, як ми зазвичай це робимо.
// Не забуваємо розширити контекст.
const bot = new Bot<MyContext>("");

// Створюємо екземпляр`I18n`.
// Продовжуйте читати, щоб дізнатися, як налаштувати екземпляр.
const i18n = new I18n<MyContext>({
  defaultLocale: "uk", // дивіться нижче для отримання додаткової інформації
  // Завантажуємо всі файли перекладу з каталогу locales/, але це не спрацює у Deno Deploy.
  directory: "locales",
});

// Завантажені наступним чином файли перекладу працюватимуть й у Deno Deploy.
// await i18n.loadLocalesDir("locales");

// Нарешті, реєструємо екземпляр i18n у боті,
// щоб повідомлення перекладалися!
bot.use(i18n);

// Зараз все налаштовано.
// Можемо отримати доступ до перекладів за допомогою `t` або `translate`.
bot.command("start", async (ctx) => {
  await ctx.reply(ctx.t("start-msg"));
});
```

:::

`ctx.t` повертає перекладений текст для вказаного ключа.
Вам не потрібно турбуватися про мову, оскільки плагін вибере її автоматично.

Вітаємо!
Ваш бот тепер розмовляє кількома мовами! :earth_africa::tada:

### З сесіями

Припустимо, що ваш бот має команду `/language`.
Загалом, у grammY ми можемо використовувати [сесії](./session) для зберігання даних користувачів кожного чату.
Щоб ваш екземпляр інтернаціоналізації знав, що сесії увімкнено, ви маєте встановити `useSession` у значення `true` в параметрах `I18n`.

Ось приклад з простою командою `/language`:

::: code-group

```ts [TypeScript]
import { Bot, Context, session, SessionFlavor } from "grammy";
import { I18n, I18nFlavor } from "@grammyjs/i18n";

interface SessionData {
  __language_code?: string;
}

type MyContext = Context & SessionFlavor<SessionData> & I18nFlavor;

const bot = new Bot<MyContext>("");

const i18n = new I18n<MyContext>({
  defaultLocale: "uk",
  useSession: true, // чи зберігати мову користувача у сесії
  directory: "locales", // завантажуємо всі файли перекладу з каталогу locales/
});

// Не забуваємо зареєструвати проміжний обробник `session`
// перед реєстрацією проміжного обробника екземпляра i18n.
bot.use(
  session({
    initial: () => {
      return {};
    },
  }),
);

// Реєструємо проміжний обробник i18n.
bot.use(i18n);

bot.command("start", async (ctx) => {
  await ctx.reply(ctx.t("greeting"));
});

bot.command("language", async (ctx) => {
  if (ctx.match === "") {
    return await ctx.reply(ctx.t("language.specify-a-locale"));
  }

  // `i18n.locales` містить всі локалі, які були зареєстровані
  if (!i18n.locales.includes(ctx.match)) {
    return await ctx.reply(ctx.t("language.invalid-locale"));
  }

  // `ctx.i18n.getLocale` повертає локаль, яка наразі використовується.
  if ((await ctx.i18n.getLocale()) === ctx.match) {
    return await ctx.reply(ctx.t("language.already-set"));
  }

  await ctx.i18n.setLocale(ctx.match);
  await ctx.reply(ctx.t("language.language-set"));
});
```

```js [JavaScript]
const { Bot, session } = require("grammy");
const { I18n } = require("@grammyjs/i18n");

const bot = new Bot("");

const i18n = new I18n({
  defaultLocale: "uk",
  useSession: true, // чи зберігати мову користувача у сесії
  directory: "locales", // завантажуємо всі файли перекладу з каталогу locales/
});

// Не забуваємо зареєструвати проміжний обробник `session`
// перед реєстрацією проміжного обробника екземпляра i18n.
bot.use(
  session({
    initial: () => {
      return {};
    },
  }),
);

// Реєструємо проміжний обробник i18n.
bot.use(i18n);

bot.command("start", async (ctx) => {
  await ctx.reply(ctx.t("greeting"));
});

bot.command("language", async (ctx) => {
  if (ctx.match === "") {
    return await ctx.reply(ctx.t("language.specify-a-locale"));
  }

  // `i18n.locales` містить всі локалі, які були зареєстровані
  if (!i18n.locales.includes(ctx.match)) {
    return await ctx.reply(ctx.t("language.invalid-locale"));
  }

  // `ctx.i18n.getLocale` повертає локаль, яка наразі використовується.
  if ((await ctx.i18n.getLocale()) === ctx.match) {
    return await ctx.reply(ctx.t("language.already-set"));
  }

  await ctx.i18n.setLocale(ctx.match);
  await ctx.reply(ctx.t("language.language-set"));
});
```

```ts [Deno]
import {
  Bot,
  Context,
  session,
  SessionFlavor,
} from "https://deno.land/x/grammy/mod.ts";
import { I18n, I18nFlavor } from "https://deno.land/x/grammy_i18n/mod.ts";

interface SessionData {
  __language_code?: string;
}

type MyContext = Context & SessionFlavor<SessionData> & I18nFlavor;

const bot = new Bot<MyContext>("");

const i18n = new I18n<MyContext>({
  defaultLocale: "uk",
  useSession: true, // чи зберігати мову користувача у сесії

  // НЕ працюватиме у Deno Deploy
  directory: "locales",
});

// Завантажені наступним чином файли перекладу працюватимуть й у Deno Deploy.
// await i18n.loadLocalesDir("locales");

// Не забуваємо зареєструвати проміжний обробник `session`
// перед реєстрацією проміжного обробника екземпляра i18n.
bot.use(
  session({
    initial: () => {
      return {};
    },
  }),
);

// Реєструємо проміжний обробник i18n.
bot.use(i18n);

bot.command("start", async (ctx) => {
  await ctx.reply(ctx.t("greeting"));
});

bot.command("language", async (ctx) => {
  if (ctx.match === "") {
    return await ctx.reply(ctx.t("language.specify-a-locale"));
  }

  // `i18n.locales` містить всі локалі, які були зареєстровані
  if (!i18n.locales.includes(ctx.match)) {
    return await ctx.reply(ctx.t("language.invalid-locale"));
  }

  // `ctx.i18n.getLocale` повертає локаль, яка наразі використовується.
  if ((await ctx.i18n.getLocale()) === ctx.match) {
    return await ctx.reply(ctx.t("language.already-set"));
  }

  await ctx.i18n.setLocale(ctx.match);
  await ctx.reply(ctx.t("language.language-set"));
});
```

:::

Коли сесії увімкнено, під час вибору мови буде використовуватися властивість `__language_code` у сесії замість `ctx.from.language_code`, яка надається клієнтом Telegram.
Коли ваш бот надсилає повідомлення, локаль вибирається з `ctx.session.__language_code`.

Існує метод `setLocale`, за допомогою якого ви можете встановити потрібну мову.
Він збереже це значення у вашій сесії.

```ts
await ctx.i18n.setLocale("de");
```

Це еквівалентно ручному налаштуванню сесії, а потім повторному узгодженню локалі:

```ts
ctx.session.__language_code = "de";
await ctx.i18n.renegotiateLocale();
```

::: tip Узгодження локалі
Якщо ви використовуєте сесії або щось інше, крім `ctx.from.language_code` для вибору власної локалі для користувача, існують ситуації, коли ви можете змінити мову під час обробки оновлення.
Наприклад, погляньте на наведений вище приклад з використанням сесій.

Якщо ви зробите лише це

```ts
ctx.session.__language_code = "de";
```

то поточна локаль в екземплярі `I18n` не оновиться.
Натомість буде оновлено виключно сесію.
Отже, зміни відбудуться лише _при наступному оновленні_.

Якщо ви не можете почекати до наступного оновлення, вам може знадобитися оновити зміни після оновлення локалі користувача.
У таких випадках використовуйте метод `renegotiateLocale`.

```ts
ctx.session.__language_code = "de";
await ctx.i18n.renegotiateLocale();
```

Після цього щоразу, коли ми використовуватимемо метод `t`, бот намагатиметься відповісти німецьким перекладом цього повідомлення, вказаним у файлі `locales/de.ftl`.

Також памʼятайте, що якщо ви використовуєте вбудовані сесії, ви можете досягти того ж результату за допомогою методу `setLocale`.
:::

::: tip Встановлення локалі, коли сесії не використовуються
У випадку [без використання сесій](#без-сесіи), якщо вам потрібно встановити локаль для користувача, ви можете зробити це за допомогою методу `useLocale`.

```ts
await ctx.i18n.useLocale("de");
```

Встановлює вказану локаль, яка буде використовуватися для майбутніх перекладів.
Ефект діє лише під час поточного оновлення, тому не зберігається.
Ви можете використовувати цей метод для зміни локалі перекладу посеред оновлення: наприклад, коли користувач змінює мову.
:::

## Власне узгодження локалі

Ви можете використовувати параметр `localeNegotiator`, щоб вказати власного узгоджувача локалі.
Цей параметр корисний, якщо ви хочете вибрати локаль на основі зовнішніх джерел: наприклад, баз даних, або в інших ситуаціях, коли ви хочете контролювати, яку локаль буде використано.

Нижче наведено типовий порядок, у якому плагін обирає локаль:

1. Якщо сесії увімкнено, спробує зчитати `__language_code` із сесії.
   Якщо він повертає правильну локаль, її буде використано.
   Якщо нічого не буде отримано або локаль буде незареєстрованою, переходить до 2-го кроку.
2. Спробує зчитати з `ctx.from.language_code`.
   Якщо він повертає правильну локаль, її буде використано.
   Якщо нічого не буде отримано або локаль буде незареєстрованою, переходить до 3-го кроку.

   > Зверніть увагу, що `ctx.from.language_code` доступний лише якщо користувач запустив бота.
   > Це означає, що якщо бот побачить користувача у групі або будь-де, але користувач не запустив бота, він не отримає доступ до `ctx.from.language_code`.

3. Спробує використати мову за замовчуванням, задану в параметрах `I18n`.
   Якщо встановлена правильна локаль, її буде використано.
   Якщо вона не вказана або вказана локаль незареєстрована, переходить до 4-го кроку.
4. Спробує використати англійську (`en`).
   Плагін сам встановлює цю локаль як резервну.
   Хоча це резервна локаль, і ми рекомендуємо мати переклад, це не є обовʼязковою вимогою.
   Якщо англійська локаль не передбачена, перейде до 5-го кроку.
5. Якщо все вищезазначене не спрацювало, використає `{ідентифікатор}` замість перекладу.
   Ми **наполегливо рекомендуємо** встановити локаль, яка існує серед ваших перекладів, як `defaultLocale` у параметрах `I18n`.

::: tip Узгодження локалі
Узгодження локалі відбувається лише один раз під час обробки оновлення Telegram, як правило.
Однак ви можете запустити `ctx.i18n.renegotiateLocale()`, щоб знову викликати узгоджувача і визначити нову локаль.
Це корисно, якщо локаль змінюється під час обробки одного оновлення.
:::

Ось приклад `localeNegotiator`, де ми використовуємо `locale` з сесії замість `__language_code`.
У цьому випадку вам не потрібно встановлювати `useSession` у значення `true` у параметрах `I18n`.

::: code-group

```ts [TypeScript]
const i18n = new I18n<MyContext>({
  localeNegotiator: (ctx) =>
    ctx.session.locale ?? ctx.from?.language_code ?? "uk",
});
```

```js [JavaScript]
const i18n = new I18n({
  localeNegotiator: (ctx) =>
    ctx.session.locale ?? ctx.from?.language_code ?? "uk",
});
```

:::

Якщо власний узгоджувач локалі поверне неправильну локаль, він повернеться назад і вибере локаль, дотримуючись наведеного вище порядку.

## Рендеринг перекладених повідомлень

Розглянемо докладніше рендеринг повідомлень.

```ts
bot.command("start", async (ctx) => {
  // Викличемо метод `translate` або `t`, щоб перекласти повідомлення,
  // вказавши його ідентифікатор та додаткові параметри:
  await ctx.reply(ctx.t("welcome"));
});
```

Тепер можемо виконати команду `/start', щоб запустити бота.
Він повинен надіслати наступне повідомлення:

```:no-line-numbers
Усім привіт!
```

### Підставлення змінних

Іноді вам може знадобитися розмістити всередині рядків такі значення, як числа та імена.
Це можна зробити за допомогою підставлення змінних.

```ts
bot.command("cart", async (ctx) => {
  // Можемо передати обʼєкт змінних для підстановки як другий аргумент
  await ctx.reply(ctx.t("cart-msg", { items: 10 }));
});
```

Обʼєкт `{ items: 10 }` називається _контекстом перекладу_ рядка `cart-msg`.

Тепер за допомогою команди `/cart` бот надішле наступне повідомлення:

```:no-line-numbers
Наразі у вашому кошику 10 товарів.
```

Спробуйте змінити значення змінної `items` і подивіться, як зміниться отримане повідомлення!
Також ознайомтеся з документацією Fluent, особливо з [документацією підставлення змінних](https://projectfluent.org/fluent/guide/placeables.html).

### Глобальні змінні підстановки

Буває корисно вказати певну кількість змінних підстановки, які мають бути доступними для _всіх_ перекладів.
Наприклад, якщо ви повторно використовуєте імʼя користувача у багатьох повідомленнях, то може бути досить втомливо передавати всюди контекст перекладу `{ name: ctx.from.first_name }`.

На допомогу приходять глобальні змінні підстановки!
Розглянемо наступний приклад:

```ts
const i18n = new I18n<MyContext>({
  defaultLocale: "uk",
  directory: "locales",
  // Визначемо глобально доступні змінні підстановки:
  globalTranslationContext(ctx) {
    return { name: ctx.from?.first_name ?? "" };
  },
});

bot.use(i18n);

bot.command("start", async (ctx) => {
  // Можемо використовувати `name` без повторного вказування!
  await ctx.reply(ctx.t("welcome"));
});
```

::: warning Потенційні проблеми з форматуванням
Типово Fluent використовує для інтерполяції розділові знаки Unicode.

Якщо ви використовуєте змінні підстановки всередині тегів або сутностей, наявність ізоляційних знаків може призвести до неправильного форматування, наприклад, звичайний текст замість очікуваного посилання або кештега.

Щоб виправити це, скористайтеся наступними налаштуваннями:

```ts
const i18n = new I18n({
  fluentBundleOptions: { useIsolating: false },
});
```

:::

## Додавання перекладів

Існує три основні способи завантаження перекладів.

### Завантаження локалей за допомогою параметра `directory`

Найпростіший спосіб додати переклади до екземпляра `I18n` --- це розмістити всі ваші переклади в каталозі й вказати назву каталогу у параметрах.

```ts
const i18n = new I18n({
  directory: "locales",
});
```

### Завантаження локалей з каталогу

Цей спосіб --- те саме, що вказати `directory` у параметрах.
Просто покладіть їх усі до каталогу та завантажте їх наступним чином:

```ts
const i18n = new I18n();

await i18n.loadLocalesDir("locales"); // асинхронна версія
i18n.loadLocalesDirSync("locales-2"); // синхронна версія
```

> Зауважте, що деякі середовища вимагають використання саме асинхронної версії.
> Наприклад, Deno Deploy не підтримує синхронні операції з файлами.

### Завантаження однієї локалі

Також можна додати до екземпляра один переклад.
Ви можете вказати шлях до файлу з перекладом за допомогою

```ts
const i18n = new I18n();

await i18n.loadLocale("uk", { filePath: "locales/uk.ftl" }); // асинхронна версія
i18n.loadLocaleSync("en", { filePath: "locales/en.ftl" }); // синхронна версія
```

або ви можете безпосередньо завантажити дані перекладу у вигляді рядка на кшталт цього:

```ts
const i18n = new I18n();

// async version
await i18n.loadLocale("uk", {
  source: `greeting = Привіт, { $name }!
language-set = Мову встановлено на українську!`,
});

// sync version
i18n.loadLocaleSync("en", {
  source: `greeting = Hello { $name }!
language-set = Language has been set to English!`,
});
```

## Оброблення локалізованого тексту

Ми змогли надіслати користувачеві локалізовані повідомлення.
Тепер давайте подивимося, як обробляти повідомлення, надіслані користувачем.
У grammY ми зазвичай використовуємо обробник `bot.hears` для оброблення вхідних повідомлень.
Але оскільки ми говоримо про інтернаціоналізацію, у цьому розділі ми розглянемо, як обробляти локалізовані вхідні повідомлення.

Ця функція стане у нагоді, якщо ваш бот має [власні клавіатури](./keyboard#власні-клавіатури), що містять локалізований текст.

Ось короткий приклад оброблення локалізованого текстового повідомлення, надісланого за допомогою власної клавіатури.
Замість обробника `bot.hears` ми використовуємо `bot.filter` у поєднанні з проміжним обробником `hears`, який надається цим плагіном.

::: code-group

```ts [TypeScript]
import { hears } from "@grammyjs/i18n";

bot.filter(hears("back-to-menu-btn"), async (ctx) => {
  await ctx.reply(ctx.t("main-menu-msg"));
});
```

```js [JavaScript]
const { hears } = require("@grammyjs/i18n");

bot.filter(hears("back-to-menu-btn"), async (ctx) => {
  await ctx.reply(ctx.t("main-menu-msg"));
});
```

```ts [Deno]
import { hears } from "https://deno.land/x/grammy_i18n/mod.ts";

bot.filter(hears("back-to-menu-btn"), async (ctx) => {
  await ctx.reply(ctx.t("main-menu-msg"));
});
```

:::

Допоміжна функція `hears` дозволяє вашому боту обробляти повідомлення, написані мовою користувача.

## Подальші кроки

- Повністю прочитайте [документацію Fluent](https://projectfluent.org/), особливо [посібник по синтаксису](https://projectfluent.org/fluent/guide/).
- Ознайомтеся з відповідними [прикладами](https://github.com/grammyjs/i18n/tree/main/examples) цього плагіна для Deno та Node.js.

## Загальні відомості про плагін

- Назва: `i18n`
- [Джерело](https://github.com/grammyjs/i18n)
- [Довідка API](/ref/i18n/)
