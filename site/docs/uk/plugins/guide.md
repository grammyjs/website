---
prev: ../plugins/
---

# Посібник по плагінам для grammY

Якщо ви бажаєте розробити свій власний плагін та опублікувати його, або якщо ви хочете дізнатися, як працюють плагіни grammY за кулісами, то це місце для вас!

> Зверніть увагу, що вже є опис [плагінів grammY](./) та їх функцій.
> Ця стаття - це глибоке занурення в їх внутрішні процеси.

## Типи плагінів в grammY

Є два основних типи плагінів в grammY:

- Middleware плагіни: задачею плагіна є повернути [middleware функцію](../guide/middleware.md), яку можна використовувати в боті grammY.
- Transformer плагіни: задачею плагіна є повернути [transformer функцію](../advanced/transformers.md), яку можна використовувати в боті grammY.

Проте іноді ви можете знайти плагіни, які роблять обидві речі.
Також є інші пакети, які не є функціями middleware або transformer, але ми також називаємо їх плагінами, оскільки вони розширюють функціональність grammY різними способами.

## Правила контрибʼютингу

Ви можете опублікувати свій плагін в одному з наступних варіантів:

- Опублікувати як **офіційний** плагін.
- Опублікувати як **плагін від сторонніх розробників**.

Якщо ви вирішите опублікувати свій плагін як сторонній, ми все ще можемо запропонувати вам видне місце на цьому вебсайті.
Однак, ми віддаємо перевагу, якщо ви опублікуєте свій плагін в [організації grammyjs](https://github.com/grammyjs) на GitHub, зробивши його офіційним плагіном.
В такому випадку вам буде надано доступ до публікації на GitHub та npm.
Крім того, ви будете відповідальні за підтримку свого коду.

Перед тим як перейти до деяких практичних прикладів, є кілька правил, на які потрібно звернути увагу, якщо ви хочете, щоб ваші плагіни були включені до списку на цьому вебсайті.

1. Необхідно мати файл README на GitHub та npm з **короткими та чіткими** інструкціями щодо використання плагіна.
2. Поясніть призначення вашого плагіна та як його використовувати, додавши сторінку до [документації](https://github.com/grammyjs/website).
Якщо ви не впевнені, як це зробити, ми можемо створити сторінку за вас.
3. Оберіть ліцензію з дозволом на використання: наприклад, MIT або ISC.

Нарешті, ви повинні знати, що хоча grammY підтримує як Node.js, так і [Deno](https://deno.land/), він є проєктом, спрямованим на Deno, і ми також підтримуємо написання плагінів для Deno (згодом й у стилі!).
Є корисний інструмент під назвою [deno2node](https://github.com/wojpawlik/deno2node), який транспілює ваш код з Deno на Node.js, щоб ми могли однаково добре підтримувати обидві платформи.
Підтримка Deno є обов'язковою тільки для офіційних плагінів, але не для плагінів сторонніх розробників.
Утім, ми дуже рекомендуємо спробувати Deno.
Ви не захочете повертатися назад.

## Розробка тестового middleware плагіну

Припустимо, ми хотіли б розробити плагін, який відповідає лише певним користувачам!
Наприклад, ми можемо вирішити відповідати тільки людям, чиє ім'я містить певне слово.
Бот просто відмовиться працювати з будь-ким іншим.

Ось приклад:

```ts
// plugin.ts

// Імпортуємо типи з grammY, ми реекспортуємо їх в `deps.deno.ts`.
import type { Context, Middleware, NextFunction } from "./deps.deno.ts";

// Ваш плагін може мати одну основну функцію, яка створює middleware.
export function onlyAccept<C extends Context>(str: string): Middleware<C> {
  // Створюємо та повертаємо middleware.
  return async (ctx, next) => {
    // Отримуємо ім'я користувача.
    const name = ctx.from?.first_name;
    // Допускаємо всі співпадаючі оновлення.
    if (name === undefined || name.includes(str)) {
      // Викликаємо нижній middleware
      await next();
    } else {
      // Скажемо їм, що ми не працюємо з такими
      await ctx.reply(`Я не буду з вами розмовляти! Ви не цікавитеся ${str}!`);
    }
  };
}
```

Тепер ми можемо використовувати це в реальному боті:

```ts
// Код плагіну знаходиться у файлі з назвою `plugin.ts`
import { onlyAccept } from "./plugin.ts";
import { Bot } from "./deps.deno.ts";

const bot = new Bot(""); // <-- Помістіть токен свого бота (https://t.me/BotFather)

bot.use(onlyAccept("grammY"));

bot.on("message", (ctx) => ctx.reply("Ви пройшли middleware плагін!"));

bot.start();
```

Ось і все!
Ви створили власний плагін, чи не так?
Але не так швидко.
Нам ще потрібно упакувати його, але перед цим давайте подивимося на transformer плагіни.

## Розробка тестового transformer плагіну

Уявіть, що ви пишете плагін, який автоматично надсилає відповідну [дію чату](https://core.telegram.org/bots/api#sendchataction) щоразу, коли бот надсилає документ.
Це означає, що під час надсилання файлу, користувачі автоматично побачать "_відправляє файл..._" як статус.
Досить круто, чи не так?

```ts
// plugin.ts
import type { Transformer } from "./deps.deno.ts";

// Головна функція плагіну
export function autoChatAction(): Transformer {
  // Створюємо та повертаємо transformer функцію.
  return async (prev, method, payload, signal) => {
    // Збережемо ідентифікатор встановленого інтервалу, щоби потім можна було очистити його.
    let handle: ReturnType<typeof setTimeout> | undefined;
    if (method === "sendDocument" && "chat_id" in payload) {
      // Тепер ми знаємо, що документ було надіслано.
      const actionPayload = {
        chat_id: payload.chat_id,
        action: "upload_document",
      };
      // Постійно встановлюємо дію чату під час завантаження файлу.
      handle ??= setInterval(() => {
        prev("sendChatAction", actionPayload).catch(console.error);
      }, 5000);
    }

    try {
      // Запускаємо справжній метод із бота.
      return await prev(method, payload, signal);
    } finally {
      // Очищаємо інтервал, щоб припинити надсилання дії в чат клієнту.
      clearInterval(handle);
    }
  };
}
```

Тепер ми можемо використовувати це в реальному боті:

```ts
import { Bot, InputFile } from "./deps.deno.ts";
// Код плагіну знаходиться у файлі з назвою `plugin.ts`
import { autoChatAction } from "./plugin.ts";

// Створюємо екземпляр бота.
const bot = new Bot(""); // <-- Помістіть токен свого бота (https://t.me/BotFather)

// Використовуємо плагін.
bot.api.config.use(autoChatAction());

bot.hears("Надішли мені документ", async (ctx) => {
  // Якщо користувач надішле цю команду, ми надішлемо йому pdf-файл (для демонстраційних цілей)
  await ctx.replyWithDocument(new InputFile("/tmp/document.pdf"));
});

// запускаємо бота
bot.start();
```

Тепер щоразу, коли ми відправляємо документ, дія чату `upload_document` буде відправлена нашому клієнту.
Зверніть увагу, що це було зроблено для демонстраційних цілей.
Telegram рекомендує використовувати дії чату тільки тоді, коли "відповідь від бота буде займати **відчутний** час на доставку".
Імовірно, вам не потрібно встановлювати статус, якщо файл дуже малий, тому тут є деякі оптимізації, які можна зробити.

## Перехід у плагін

Незалежно від того, який тип плагіна ви створили, ви повинні запакувати його в пакет.
Це досить просте завдання.
Немає конкретних правил щодо того, як це зробити, і npm - ваша перлина, але щоб все було організовано, у нас є для вас пропозиція шаблону.
Ви можете завантажити [код з нашого репозиторію шаблонів плагінів на GitHub](https://github.com/grammyjs/plugin-template) і почати розробляти свій плагін без витрачення часу на налаштування.

Початкова структура каталогів:

```asciiart:no-line-numbers
plugin-template/
├─ src/
│  ├─ deps.deno.ts
│  ├─ deps.node.ts
│  └─ index.ts
├─ package.json
├─ tsconfig.json
└─ README.md
```

**`deps.deno.ts`** та **`deps.node.ts`**: це для розробників, які бажають написати плагін для Deno, а потім транспілювати його для Node.js.
Як зазначалося раніше, ми використовуємо інструмент `deno2node` для транспіляції нашого коду з Deno на Node.js.
У `deno2node` є функція, яка дозволяє надавати йому файли, специфічні для середовища виконання.
Ці файли повинні бути поруч із іншими файлами та мають назву зі структурою іменування `*.deno.ts` та `*.node.ts`, як [пояснено в документації](https://github.com/wojpawlik/deno2node#runtime-specific-code).
Саме тому є два файли: `deps.deno.ts` та `deps.node.ts`.
Якщо є якісь залежності, специфічні для Node.js, помістіть їх у `deps.node.ts`, в іншому випадку залиште його порожнім.

> _**Примітка**_: ви також можете використовувати інші інструменти, такі як [deno dnt](https://github.com/denoland/dnt), для траспіляції вашого коду Deno, або використовувати іншу структуру каталогів.
> Важливо не інструменти, які ви використовуєте, а те, що пишете код для Deno краще і простіше.

**`tsconfig.json`**: Це конфігураційний файл компілятора TypeScript, який використовується `deno2node` для транспіляції твого коду.
У репозиторії надається конфігураційний файл за замовчуванням як пропозиція.
Він відповідає конфігурації TypeScript, яку використовує Deno внутрішньо, і ми рекомендуємо, щоб ти залишався з цією конфігурацією.

**`package.json`**: Файл package.json для npm-версії вашого плагіна.
**Переконайтеся, що зміните його згідно з вашим проектом**.

**`README.md`**: інструкції щодо використання плагіну.
**Переконайтеся, що зміните його згідно з вашим проєктом**.

**`index.ts`**: файл, що містить бізнес-логіку вашого плагіна, тобто ваш основний код плагіну.

## Шаблон плагіну

Якщо ви хочете розробити плагін для grammY, але не знаєте, з чого почати, ми дуже рекомендуємо використовувати код шаблону, що знаходиться у [нашому репозиторії](https://github.com/grammyjs/plugin-template).
Ви можете клонувати код до себе та почати програмувати, користуючись тим, що було розглянуто у цій статті.
У цьому репозиторії також є додаткові корисні файли: наприклад, `.editorconfig`, `LICENSE`, `.gitignore` тощо, але ви можете видалити їх за потреби.

## Мені не подобається Deno

Ну що ж, це втрата!
Але ви також можете писати свої плагіни тільки для Node.js.
Ви все ще можете опублікувати плагін і додати його до списку сторонніх плагінів на цьому вебсайті.
У такому випадку ви можете використовувати будь-яку структуру каталогів, яку бажаєте, якщо вона організована, як будь-який інший проєкт npm.
Просто встановіть grammY через npm з `npm install grammy` і починайте програмувати.

## Як подати заявку?

Якщо у вас є готовий плагін, ви можете просто створити pull request на GitHub відповідно до [правил контрибʼютингу](#правила-котрибʼютингу) або повідомити нас у [чаті спільноти](https://t.me/grammyjs) для подальшої допомоги.
