---
prev: false
next: false
---

# Лимит запросов пользователей (`ratelimiter`)

ratelimiter --- это middleware для ограничения скорости ботов Telegram, созданных с помощью grammY или [Telegraf](https://github.com/telegraf/telegraf).
Проще говоря, это плагин, который поможет вам предотвратить сильную спам рассылку в ваших ботах.
Чтобы лучше понять суть ratelimiter, вы можете взглянуть на следующую иллюстрацию:

![Роль ratelimiter в борьбе со спамом](/images/ratelimiter-role.png)

## Как именно это работает?

При нормальных обстоятельствах каждый запрос будет обработан и получит ответ от вашего бота, а значит, заспамить его будет не так уж сложно.
Каждый пользователь может отправлять несколько запросов в секунду, и вашему коду придется обрабатывать каждый запрос, но как это остановить?
С помощью ratelimiter!

::: warning Ограничение скорости пользователей, а не серверов Telegram!
Обратите внимание, что этот пакет **НЕ** ограничивает входящие запросы от серверов Telegram, вместо этого он отслеживает входящие запросы по `from.id` и отклоняет их по прибытии, поэтому на ваши сервера не ложится дополнительная нагрузка по обработке.
:::

## Настройка

Этот плагин предоставляет 5 настраиваемых опций:

- `timeFrame`: Временной интервал, в течение которого будут отслеживаться запросы (по умолчанию `1000` мс).
- `limit`: Количество запросов, разрешенных в каждом `таймфрейме` (по умолчанию `1`).
- `storageClient`: Тип хранилища, которое будет использоваться для отслеживания пользователей и их запросов.
  По умолчанию используется `MEMORY_STORE`, который использует in-memory [Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map), но вы также можете передать клиент Redis (подробнее в [О storageClient](#о-storageclient)).
- `onLimitExceeded`: Функция, описывающая, что делать, если пользователь превысил лимит (по умолчанию игнорирует дополнительные запросы).
- `keyGenerator`: Функция, возвращающая уникальный ключ, сгенерированный для каждого пользователя (по умолчанию используется `from.id`).
  Этот ключ используется для идентификации пользователя, поэтому он должен быть уникальным, специфичным для пользователя и иметь строковый формат.

### О `storageClient`

Вариант `MEMORY_STORE` или отслеживание в памяти подходит для большинства ботов, однако если вы реализуете кластеризацию для своего бота, вы не сможете эффективно использовать хранилище в памяти.
Именно поэтому предусмотрена возможность использования Redis.
Вы можете передать клиент Redis из [ioredis](https://github.com/redis/ioredis) или [redis](https://deno.land/x/redis), если вы используете Deno.
В действительности, любой драйвер Redis, реализующий методы `incr` и `pexpire`, должен работать просто отлично.
ratelimiter не зависит от драйвера.

> Примечание: Для использования клиента хранилища Redis с ratelimiter на вашем сервере должен быть установлен redis-server **2.6.0** и выше.
> Более старые версии Redis не поддерживаются.

## Как использовать

Существует два способа использования ratelimiter:

- Принятие настроек по умолчанию ([Настройки по умолчанию](#настроики-по-умолчанию)).
- Передача пользовательского объекта, содержащего ваши настройки ([Ручная настройка](#ручная-настроика)).

### Настройки по умолчанию

Этот фрагмент демонстрирует самый простой способ использования ratelimiter, который принимает поведение по умолчанию:

::: code-group

```ts [TypeScript]
import { limit } from "@grammyjs/ratelimiter";

// Ограничивает обработку сообщений до одного сообщения в секунду для каждого пользователя.
bot.use(limit());
```

```js [JavaScript]
const { limit } = require("@grammyjs/ratelimiter");

// Ограничивает обработку сообщений до одного сообщения в секунду для каждого пользователя.
bot.use(limit());
```

```ts [Deno]
import { limit } from "https://deno.land/x/grammy_ratelimiter/mod.ts";

// Ограничивает обработку сообщений до одного сообщения в секунду для каждого пользователя.
bot.use(limit());
```

:::

### Ручная настройка

Как упоминалось ранее, вы можете передать объект `Options` в метод `limit()`, чтобы изменить поведение ratelimiter.

::: code-group

```ts [TypeScript]
import Redis from "ioredis";
import { limit } from "@grammyjs/ratelimiter";

const redis = new Redis(...);

bot.use(
  limit({
    // Разрешите обрабатывать только 3 сообщения каждые 2 секунды.
    timeFrame: 2000,
    limit: 3,

    // По умолчанию используется значение «MEMORY_STORE». Если вы не хотите использовать Redis, не передавайте storageClient вообще.
    storageClient: redis,

    // Эта функция вызывается при превышении лимита.
    onLimitExceeded: async (ctx) => {
      await ctx.reply("Пожалуйста, воздержитесь от отправки слишком большого количества запросов!");
    },

    // Обратите внимание, что ключ должен быть числом в строковом формате, например «123456789».
    keyGenerator: (ctx) => {
      return ctx.from?.id.toString();
    },
  })
);
```

```js [JavaScript]
const Redis = require("ioredis");
const { limit } = require("@grammyjs/ratelimiter");

const redis = new Redis(...);

bot.use(
  limit({
    // Разрешите обрабатывать только 3 сообщения каждые 2 секунды.
    timeFrame: 2000,
    limit: 3,

    // По умолчанию используется значение «MEMORY_STORE». Если вы не хотите использовать Redis, не передавайте storageClient вообще.
    storageClient: redis,

    // Эта функция вызывается при превышении лимита.
    onLimitExceeded: async (ctx) => {
      await ctx.reply("Пожалуйста, воздержитесь от отправки слишком большого количества запросов!");
    },

    // Обратите внимание, что ключ должен быть числом в строковом формате, например «123456789».
    keyGenerator: (ctx) => {
      return ctx.from?.id.toString();
    },
  })
);
```

```ts [Deno]
import { connect } from "https://deno.land/x/redis/mod.ts";
import { limit } from "https://deno.land/x/grammy_ratelimiter/mod.ts";

const redis = await connect(...);

bot.use(
  limit({
    // Разрешите обрабатывать только 3 сообщения каждые 2 секунды.
    timeFrame: 2000,
    limit: 3,

    // По умолчанию используется значение «MEMORY_STORE». Если вы не хотите использовать Redis, не передавайте storageClient вообще.
    storageClient: redis,

    // Эта функция вызывается при превышении лимита.
    onLimitExceeded: async (ctx) => {
      await ctx.reply("Пожалуйста, воздержитесь от отправки слишком большого количества запросов!");
    },

    // Обратите внимание, что ключ должен быть числом в строковом формате, например «123456789».
    keyGenerator: (ctx) => {
      return ctx.from?.id.toString();
    },
  })
);
```

:::

Как видно из примера выше, каждому пользователю разрешено отправлять 3 запроса каждые 2 секунды.
Если пользователь отправляет больше запросов, бот отвечает _Пожалуйста, воздержитесь от отправки слишком большого количества запросов_.
Этот запрос не будет отправлен дальше и сразу же будет пропущен, так как мы не вызываем [next()](../guide/middleware#стек-middleware) в middleware.

> Примечание: Чтобы избежать переполнения серверов Telegram, `onLimitExceeded` выполняется только один раз в каждом `таймфрейме`.

Другим вариантом использования может быть ограничение входящих запросов от чата, а не от конкретного пользователя:

::: code-group

```ts [TypeScript]
import { limit } from "@grammyjs/ratelimiter";

bot.use(
  limit({
    keyGenerator: (ctx) => {
      if (ctx.hasChatType(["group", "supergroup"])) {
        // Обратите внимание, что ключ должен быть числом в формате строки, например «123456789».
        return ctx.chat.id.toString();
      }
    },
  }),
);
```

```js [JavaScript]
const { limit } = require("@grammyjs/ratelimiter");

bot.use(
  limit({
    keyGenerator: (ctx) => {
      if (ctx.hasChatType(["group", "supergroup"])) {
        // Обратите внимание, что ключ должен быть числом в формате строки, например «123456789».
        return ctx.chat.id.toString();
      }
    },
  }),
);
```

```ts [Deno]
import { limit } from "https://deno.land/x/grammy_ratelimiter/mod.ts";

bot.use(
  limit({
    keyGenerator: (ctx) => {
      if (ctx.hasChatType(["group", "supergroup"])) {
        // Обратите внимание, что ключ должен быть числом в формате строки, например «123456789».
        return ctx.chat.id.toString();
      }
    },
  }),
);
```

:::

В этом примере мы использовали `chat.id` в качестве уникального ключа для ограничения скорости.

## Краткая информация о плагине

- Название: `ratelimiter`
- [Исходник](https://github.com/grammyjs/ratelimiter)
- [Ссылка](/ref/ratelimiter/)
