# Масштабирование I: большой размер кода

Как только ваш бот вырастет в сложности, вы столкнетесь с проблемой, как структурировать кодовую базу приложения.
Естественно, вы можете разделить ее по файлам.

## Возможное решение

> grammY еще довольно молод и пока не предоставляет официальных интеграций с DI-контейнерами.
> Подпишитесь на [@grammyjs_news](https://t.me/grammyjs_news), чтобы получить уведомление, как только мы начнем поддерживать это.

Вы вольны структурировать свой код так, как вам нравится, и не существует универсального решения.
Тем не менее, простая и проверенная стратегия структурирования кода заключается в следующем.

1. Группируйте вещи, которые семантически принадлежат друг другу, в одном файле (или, в зависимости от размера кода, директории).
   Каждая из этих частей раскрывает middleware, который будет обрабатывать назначенные сообщения.
2. Централизованно создайте экземпляр бота, который объединит все middleware.
3. (Необязательно.) Предварительно отфильтруйте обновления централизованно и отправляйте их только в нужном направлении.
   Для этого вам может пригодиться `bot.route` ([Ссылка на API](/ref/core/composer#route)) или, как вариант, плагин [router](../plugins/router).

Выполняемый пример, реализующий описанную выше стратегию, можно найти в репозитории [Репозиторий бота для примера](https://github.com/grammyjs/examples/tree/main/scaling).

## Пример структуры

Для очень простого бота, управляющего списком TODO, можно представить такую структуру.

```asciiart:no-line-numbers
src/
├── bot.ts
└── todo/
    ├── item.ts
    └── list.ts
```

`item.ts` просто определяет некоторые вещи об элементах TODO, и эти части кода используются в `list.ts`.

В `list.ts`, вы можете сделать следующее:

```ts
export const lists = new Composer();

// Зарегистрируйте здесь несколько обработчиков, которые будут работать с вашим middleware обычным способом.
lists.on("message", async (ctx) => {
  /* ... */
});
```

> Обратите внимание, что если вы используете TypeScript, то при создании композитора вам нужно передать ваш [пользовательский тип контекста](../guide/context#кастомизация-объекта-контекста).
> Например, вам нужно будет использовать `new Composer<MyContext>()`.

Как вариант, вы можете использовать [погрешность ошибок](../guide/errors#границы-ошибок) для обработки всех ошибок, возникающих внутри вашего модуля.

Теперь в `bot.ts` вы можете установить этот модуль следующим образом:

```ts
import { lists } from "./todo/list";

const bot = new Bot("");

bot.use(lists);
// ... здесь может быть множество других модулей как todo

bot.start();
```

Как вариант, вы можете использовать [плагин router](../plugins/router) или [`bot.route`](/ref/core/composer#route) для объединения различных модулей, если вы можете заранее определить, какой middleware за это отвечает.

Однако помните, что точный способ структурирования вашего бота очень сложно назвать в общем виде.
Как и всегда в программном обеспечении, делайте так, чтобы это имело наибольший смысл :wink:

## Определения типов для извлеченного middleware

Приведенная выше структура с использованием композиторов работает хорошо.
Однако иногда вы можете оказаться в ситуации, когда вам нужно извлечь обработчик в функцию, а не создавать новый композитор и добавлять в него логику.
Это потребует от вас добавления правильных определений типов в обработчики, поскольку они больше не могут быть выведены через композитор.

grammY экспортирует определения типов для всех **узких типов middleware**, таких как middleware, которое вы можете передавать обработчикам команд.
Кроме того, он экспортирует определения типов для **узких контекстных объектов**, которые используются в этом middleware.
Оба типа параметризуются вашим [пользовательским контекстным объектом](../guide/context#кастомизация-объекта-контекста).
Таким образом, обработчик команд будет иметь тип `CommandMiddleware<MyContext>` и его контекстный объект `CommandContext<MyContext>`.
Их можно использовать следующим образом.

::: code-group

```ts [Node.js]
import {
  type CallbackQueryMiddleware,
  type CommandContext,
  type NextFunction,
} from "grammy";

function commandMiddleware(ctx: CommandContext<MyContext>, next: NextFunction) {
  // обработка команд
}
const callbackQueryMiddleware: CallbackQueryMiddleware<MyContext> = (ctx) => {
  // обработка запросов обратного вызова
};

bot.command(["start", "help"], commandMiddleware);
bot.callbackQuery("query-data", callbackQueryMiddleware);
```

```ts [Deno]
import {
  type CallbackQueryMiddleware,
  type CommandContext,
  type NextFunction,
} from "https://deno.land/x/grammy/mod.ts";

function commandMiddleware(ctx: CommandContext<MyContext>, next: NextFunction) {
  // обработка команд
}
const callbackQueryMiddleware: CallbackQueryMiddleware<MyContext> = (ctx) => {
  // обработка запросов обратного вызова
};

bot.command(["start", "help"], commandMiddleware);
bot.callbackQuery("query-data", callbackQueryMiddleware);
```

:::

Ознакомьтесь со справочником [API-справочник псевдонимов типов](/ref/core/#type-aliases), чтобы увидеть обзор всех псевдонимов типов, которые экспортирует grammY.
