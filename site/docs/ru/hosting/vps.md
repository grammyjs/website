---
prev: false
next: false
---

<!-- markdownlint-disable no-duplicate-heading -->

# Хостинг: VPS

Виртуальный частный сервер, чаще всего называемый VPS, представляет собой виртуальную машину, работающую в облаке, где вы, разработчик, имеете полный контроль над системой.

## Аренда сервера

> Чтобы иметь возможность следовать этому руководству, вам сначала нужно арендовать VPS.
> В этом разделе мы расскажем, как это сделать.
> Если у вас уже есть VPS для работы, переходите к [следующему разделу](#запуск-бота).

В этом руководстве мы будем использовать услуги [Hostinger](https://hostinger.com).

> Вы можете выбрать провайдера по своему усмотрению.
> Все провайдеры предоставляют одинаковые услуги, поэтому у вас не возникнет проблем с технической частью этой статьи.
> Вы можете воспринимать эту часть как обзор того, как работает аренда сервера.
> Если вы новичок, вы можете использовать это руководство для аренды своего первого сервера!

::: tip Аналог сервера
Если вы не можете или не хотите арендовать сервер, но при этом хотите поиграть с запуском бота на VPS, вы можете выполнить это руководство на виртуальной машине.
Для этого воспользуйтесь таким приложением, как [VirtualBox](https://virtualbox.org).
Создайте виртуальную машину с нужным дистрибутивом Linux, чтобы имитировать сервер Linux.
:::

Перейдите на страницу [VPS-Хостинг](https://hostinger.com/vps-hosting).
Мы будем использовать тарифный план "KVM 1".
Ресурсов "KVM 1" достаточно для ботов с большой аудиторией, а тем более для нашего тестового бота.

Нажмите кнопку "Add to cart".
Вы будете автоматически перенаправлены на страницу оформления заказа, где также сразу зарегистрируетесь на Hostinger.

::: warning Измените срок аренды!
Типичный срок аренды --- 1-2 года (маркетинговая уловка), и это стоит больших денег.
Скорее всего, вам это не нужно, поэтому для начала можно арендовать сервер на месяц, что гораздо дешевле.

В любом случае, Hostinger предоставляет 30-дневную гарантию возврата денег.
:::

После оплаты вы сможете настроить свой сервер:

1. **Местоположение.**
   Мы рекомендуем вам [выбрать место](../guide/api#выбор-места-расположения-дата-центра), ближайшее к Амстердаму.
   Главный сервер Bot API расположен в Амстердаме.
   Если вы используете [собственный сервер Bot API](../guide/api#запуск-локального-api-сервера-бота), выберите вместо Амстердама, ближайшую к нему локацию.
2. **Тип сервера.**
   Выберите вариант "Clean OS."
3. **Операционная система.**
   Мы будем использовать Ubuntu 22.04.
   Если вы выберете другую систему, некоторые шаги могут отличаться, поэтому будьте внимательны.
4. **Имя сервера.**
   Выберите любое имя, которое вам нравится.
5. **Пароль рута.**
   Придумайте надежный пароль и храните его в надежном месте!
6. **SSH-ключ**.
   Пропустите этот шаг.
   Мы настроим SSH-ключи [позже](#ssh-ключи).

После создания сервера вы можете подключиться к нему с помощью SSH:

> SSH (_Secure Shell_) --- это сетевой протокол, который можно использовать для удаленного управления компьютером.

```sh
ssh root@<ip-адрес>
```

Замените `<ip-адрес>` на IP адрес вашего сервера, который вы можете найти на странице управления сервером.

::: tip Настройка SSH
Запоминать, какой IP адрес и чье имя необходимо для подключения к серверу, может быть сложно и утомительно.
Чтобы избавиться от этих рутинных действий и улучшить работу с сервером, вы можете настроить SSH, создав на своем компьютере файл `~/.ssh/config` (<https://linuxhandbook.com/ssh-config-file/>), в котором под определенными произвольными идентификаторами будут храниться все данные, необходимые для подключения к серверу.
Это выходит за рамки данной статьи, поэтому вам придется настраивать его самостоятельно.
:::

::: tip Отдельный пользователь для каждого приложения
В этом руководстве все действия с сервером будут выполняться от имени пользователя root.
Это сделано специально, чтобы упростить данное руководство.
Однако в реальности root пользователь должен отвечать только за общие службы (веб-сервер, база данных и т. д.), а приложения должны запускаться отдельными пользователями, не являющимися root пользователями.
Такой подход обеспечивает безопасность конфиденциальных данных и предотвращает взлом всей системы.
В то же время он накладывает некоторые неудобства.
Описание всех этих моментов излишне увеличивает сложность статьи, чего мы стараемся избегать.
:::

## Запуск бота

Теперь в нашем распоряжении есть сервер, на котором мы можем запустить бота, чтобы он работал круглосуточно.

Чтобы упростить начало статьи, мы пропустили шаг автоматической доставки кода на сервер каждый раз после размещения вашего кода, но он описан [ниже](#ci-cd).

Пока же вы можете скопировать локальные файлы на удаленный сервер с помощью следующей команды.
Обратите внимание, что `-r` копирует рекурсивно, поэтому вам нужно указать только корневой каталог вашего проекта:

```sh
scp -r <путь-до-локальной-директории-с-ботом> root@<ip-адрес>:<путь-до-удалённой-директории>
```

Замените `<путь-до-локальной-директории-с-ботом>` на путь к директории проекта на вашем локальном диске, `<ip-адрес>` на IP адрес вашего сервера, а `<путь-до-удалённой-директории>` на путь к директории, где на сервере должен храниться исходный код бота.

Как уже говорилось выше, теперь вы можете открыть удаленный терминал на вашем VPS, запустив сессию SSH.

```sh
ssh root@<ip-адрес>
```

Обратите внимание, как изменилась командная строка.
Это означает, что вы теперь подключены к удаленной машине.
Каждая введенная вами команда будет выполняться на вашем VPS.
Попробуйте запустить `ls`, чтобы убедиться, что вы успешно скопировали исходные файлы.

В оставшейся части этой страницы предполагается, что вы можете подключиться к своему VPS.
Все следующие команды должны быть запущены в сессии SSH.

:::tip Не забудьте установить среду выполнения!
Чтобы запустить бота, вам нужно установить на сервер Node.js или Deno, в зависимости от среды выполнения, в которой будет работать бот.
Это выходит за рамки данной статьи, поэтому вам придется сделать это самостоятельно.
Вероятно, вы уже делали это при [начале работы](../guide/getting-started), поэтому вам должны быть знакомы эти шаги :wink:
:::

Ниже приведены два способа поддержания бесперебойной работы бота: использование [systemd](#systemd) или [PM2](#pm2).

### systemd

systemd --- это мощный менеджер служб, который предустановлен во многих дистрибутивах Linux, в основном на базе Debian, таких как Ubuntu.

#### Создание команды для запуска

1. Получите абсолютный путь к вашей среде выполнения:

   ::: code-group

   ```sh [Deno]
   which deno
   ```

   ```sh [Node.js]
   which node
   ```

   :::

2. У вас должен быть абсолютный путь к директории вашего бота.

3. Ваша команда запуска должна выглядеть следующим образом:

   ```sh
   <путь_к_среде_выполнения> <параметры> <абсолютный_путь_к_фалу_запуска>

   # Путь к директории бота: /home/user/bot1/

   # Deno пример:
   # /home/user/.deno/bin/deno --allow-all run mod.ts

   # Node.js пример:
   # /home/user/.nvm/versions/node/v16.9.1/bin/node index.js
   ```

#### Создание службы

1. Перейдите в каталог служб:

   ```sh
   cd /etc/systemd/system
   ```

2. Откройте новый служебный файл в редакторе:

   ```sh
   nano <app-name>.service
   ```

   > Замените `<app-name>` на любой идентификатор.
   > `<app-name>.service` будет именем вашего сервиса.

3. Добавьте следующее содержание:

   ```text
   [Unit]
   After=network.target

   [Service]
   WorkingDirectory=<путь_до_директории_бота>
   ExecStart=<команда_для_запуска>
   Restart=on-failure

   [Install]
   WantedBy=multi-user.target
   ```

   Замените `<путь_до_директории_бота>` на абсолютный путь к директории вашего бота, а `<команда_для_запуска>` на команду, которую вы получили [выше](#создание-команды-для-запуска).

   Вот краткое объяснение конфигурации сервиса:

   - `After=network.target` --- указывает, что приложение должно быть запущено после загрузки модуля Internet.
   - `WorkingDirectory=<путь_до_директории_бота>` --- задает текущий рабочий каталог процесса.
     Это позволяет использовать относительные ресурсы, такие как файл `.env`, который содержит все необходимые переменные окружения.
   - `ExecStart=<команда_для_запуска>` --- задает команду запуска.
   - `Restart=on-failure` --- указывает, что приложение должно перезапускаться после сбоя.
   - `WantedBy=multi-user.target` --- определяет состояние системы, в котором должна быть запущена служба.
     `multi-user.target` --- типичное значение для серверов.

   > Для получения дополнительной информации о файлах системы читайте [this](https://docs.redhat.com/en/documentation/red_hat_enterprise_linux/9/html/using_systemd_unit_files_to_customize_and_optimize_your_system/assembly_working-with-systemd-unit-files_working-with-systemd).

4. Перезагружайте systemd при каждом изменении службы:

   ```sh
   systemctl daemon-reload
   ```

#### Управление службой

```sh
# Замените `<название-службы>` на имя файла созданной вами службы.

# Чтобы запустить службу
systemctl start <название-службы>

# Чтобы просмотреть служебные логи
journalctl -u <название-службы>

# Чтобы перезапустить службу
systemctl restart <название-службы>

# Чтобы остановить службу
systemctl stop <название-службы>

# Чтобы включить запуск службы при загрузке сервера
systemctl enable <название-службы>

# Чтобы отключить запуск службы при загрузке сервера
systemctl disable <название-службы>
```

Запуск службы должен запустить вашего бота!

### PM2

[PM2](https://pm2.keymetrics.io) --- это daemon-менеджер процессов для Node.js, который поможет вам управлять и поддерживать работу вашего приложения в режиме 24/7.

PM2 разработан специально для управления приложениями, написанными на Node.js.
Однако его можно использовать и для управления приложениями, написанными на других языках или средах исполнения.

#### Установка

::: code-group

```sh [NPM]
npm install -g pm2
```

```sh [Yarn]
yarn global add pm2
```

```sh [pnpm]
pnpm add -g pm2
```

:::

#### Создание приложения

PM2 предлагает два способа создания приложения:

1. Использовать интерфейс командной строки.
2. Использовать [конфигурационный файл](https://pm2.keymetrics.io/docs/usage/application-declaration/).

Первый способ удобен при знакомстве с PM2.
Однако при развертывании следует использовать второй метод, что мы и сделали в нашем случае.

Создайте на сервере в директории, где хранится сборка бота, файл `ecosystem.config.js` со следующим содержанием:

```js
module.exports = {
  apps: [
    {
      name: "<название-приложения>",
      script: "<команда-для-запуска>",
    },
  ],
};
```

Замените `<название-приложения>` на любой идентификатор, а `<команда-для-запуска>` --- на команду для запуска бота.

#### Управление приложением

Ниже перечислены команды, которые можно использовать для управления приложением.

```sh
# Если файл `ecosystem.config.js` находится в текущем каталоге,
# вы можете ничего не указывать для запуска приложения.
# Если приложение уже запущено, эта команда перезапустит его.
pm2 start

# Все следующие команды требуют указания имени приложения
# или файл `ecosystem.config.js`.
# Чтобы применить действие ко всем приложениям, укажите `all`.

# Чтобы перезапустить приложение
pm2 restart <app-name>

# Чтобы перезагрузить приложение
pm2 reload <app-name>

# Чтобы остановить приложение
pm2 stop <app-name>

# Чтобы удалить приложение
pm2 delete <app-name>
```

#### Сохранение операций приложения

Если сервер перезагрузится, ваш бот не возобновит работу.
Чтобы бот возобновил работу, необходимо подготовить PM2 к этому.

На сервере в терминале выполните следующую команду:

```sh
pm2 startup
```

Вам будет предложена команда, которую нужно выполнить, чтобы PM2 автоматически запускался после перезагрузки сервера.

Затем выполните еще одну команду:

```sh
pm2 save
```

Эта команда сохранит список текущих приложений, чтобы их можно было запустить после перезагрузки сервера.

Если вы создали новое приложение и хотите сохранить и его, просто запустите `pm2 save` снова.

## Запуск бота на вебхуках

Чтобы запустить бота на вебхуках, вам нужно использовать веб-фреймворк и **НЕ** вызывать `bot.start()`.

Вот пример кода для запуска бота по вебхукам, который нужно добавить в основной файл бота:

::: code-group

```ts [Node.js]
import { webhookCallback } from "grammy";
import { fastify } from "fastify";

const server = fastify();

server.post(`/${bot.token}`, webhookCallback(bot, "fastify"));

server.listen();
```

```ts [Deno]
import { webhookCallback } from "https://deno.land/x/grammy/mod.ts";

const handleUpdate = webhookCallback(bot, "std/http");

Deno.serve(async (req) => {
  if (req.method === "POST") {
    const url = new URL(req.url);
    if (url.pathname.slice(1) === bot.token) {
      try {
        return await handleUpdate(req);
      } catch (err) {
        console.error(err);
      }
    }
  }
  return new Response();
});
```

:::

### Аренда домена

Чтобы подключить бота, работающего на вебхуках, к внешнему миру, вам нужно приобрести домен.
Мы будем объяснять это на примере Hostinger, но есть и множество других сервисов, и все они работают аналогично.

Перейдите на [страницу поиска доменного имени](https://www.hostinger.com/domain-name-search).
В поле ввода текста введите доменное имя вида `<имя>.<доменная зона>`.
Например, `example.com`.

Если нужный домен свободен, нажмите кнопку `Add` рядом с ним.
Вы будете автоматически перенаправлены на страницу оформления заказа, где вы также сразу зарегистрируетесь в Hostinger, если вы еще не зарегистрированы.
Оплатите домен.

#### Домен, указывающий на VPS

Прежде чем ваш домен сможет работать с вашим VPS, вам необходимо указать домен на ваш сервер.
Для этого в [Панели управления Hostinger](https://hpanel.hostinger.com) нажмите кнопку "Manage" рядом с вашим доменом.
Затем перейдите на страницу управления DNS-записями, нажав на кнопку "DNS / Name Servers" в меню слева.

> Сначала узнайте IP адрес вашего VPS.

В списке записей DNS найдите запись типа `A` с именем `@`.
Отредактируйте эту запись, изменив IP адрес в поле "Points to" на IP адрес вашего VPS, и установите TTL на 3600.

Затем найдите и удалите запись типа `CNAME` с именем `www`.
Вместо нее создайте новую запись типа `A` с именем `www`, указывающую на IP адрес вашего VPS, и установите TTL на 3600.

> Если у вас возникнут проблемы, воспользуйтесь другим методом, описанным в [базе знаний](https://www.hostinger.com/support/1583227-how-to-point-a-domain-to-your-vps-at-hostinger/).

### Настройка веб сервера

Чтобы сайт заработал и бот начал получать обновления от Telegram, необходимо настроить веб-сервер.
Мы будем использовать [Caddy](https://caddyserver.com).

Caddy --- это мощный веб-сервер с открытым исходным кодом и автоматическим HTTPS.

::: tip Веб сервер
Мы используем Caddy, потому что, в отличие от обычных веб-серверов, таких как Nginx или Apache, он автоматически настраивает SSL-сертификаты.
Это значительно упрощает работу над статьей.
Однако вы можете выбрать любой веб-сервер.
:::

#### Установка

Следующие пять команд загрузят и автоматически запустят Caddy как службу systemd под названием `caddy`.

```sh
apt install -y debian-keyring debian-archive-keyring apt-transport-https curl
curl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/gpg.key' | gpg --dearmor -o /usr/share/keyrings/caddy-stable-archive-keyring.gpg
curl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/debian.deb.txt' | tee /etc/apt/sources.list.d/caddy-stable.list
apt update
apt install caddy
```

> Другие варианты установки см. в [Руководстве по установке Caddy](https://caddyserver.com/docs/install).

Проверьте состояние Caddy:

```sh
systemctl status caddy
```

::: details Устранение неполадок
Некоторые хостинг-провайдеры предоставляют VPS с предустановленным веб-сервером, например [Apache](https://httpd.apache.org).
Несколько веб-серверов не могут работать на одной машине одновременно.
Для работы Caddy необходимо остановить и выключить другой веб-сервер:

```sh
systemctl stop <имя-службы>
systemctl disable <имя-службы>
```

Замените `имя-службы` на имя службы веб-сервера, которая мешает работе Caddy.

:::

Теперь, если вы откроете IP адрес вашего сервера в браузере, вы увидите типичную страницу с инструкциями по настройке Caddy.

#### Настройка

Чтобы Caddy мог обрабатывать запросы, поступающие в наш домен, нам нужно изменить конфигурацию Caddy.

Выполните следующую команду, чтобы открыть файл конфигурации Caddy:

```sh
nano /etc/caddy/Caddyfile
```

Вы увидите следующую конфигурацию по умолчанию:

```text
# The Caddyfile is an easy way to configure your Caddy web server.
#
# Unless the file starts with a global options block, the first
# uncommented line is always the address of your site.
#
# To use your own domain name (with automatic HTTPS), first make
# sure your domain's A/AAAA DNS records are properly pointed to
# this machine's public IP, then replace ":80" below with your
# domain name.

:80 {
  # Set this path to your site's directory.
  root * /usr/share/caddy

  # Enable the static file server.
  file_server

  # Another common task is to set up a reverse proxy:
  # reverse_proxy localhost:8080

  # Or serve a PHP site through php-fpm:
  # php_fastcgi localhost:9000
}

# Refer to the Caddy docs for more information:
# https://caddyserver.com/docs/caddyfile
```

Чтобы бот работал, сделайте конфигурацию примерно такой:

```text
<домен> {
  reverse_proxy /<токен> localhost:<порт>
}
```

Замените `<домен>` на ваш домен, `<токен>` на токен вашего бота, а `<порт>` на порт, на котором вы хотите запустить своего бота.

Перезагружайте Caddy каждый раз, когда вы изменяете конфигурационный файл сайта, используя следующую команду:

```sh
systemctl reload caddy
```

Теперь все запросы по адресу `https://<домен>/<токен>` будут перенаправляться на адрес `http://localhost:<порт>/<токен>`, где запущен вебхук бота.

#### Подключение вебхука к Telegram

Все, что вам нужно сделать --- это указать Telegram, куда отправлять обновления.
Для этого откройте браузер и перейдите на страницу по следующей ссылке:

```text
https://api.telegram.org/bot<токен>/setWebhook?url=https://<домен>/<токен>
```

Замените `<токен>` на токен вашего бота, а `<домен>` на ваш домен.

## CI/CD

[CI/CD](https://about.gitlab.com/topics/ci-cd/) --- важная часть современного процесса разработки программного обеспечения.
Это руководство охватывает практически весь конвейер [CI/CD](https://about.gitlab.com/topics/ci-cd/cicd-pipeline/).

Мы сосредоточимся на написании скриптов для GitHub и GitLab.
При необходимости вы можете легко адаптировать приведенные ниже примеры к выбранному вами сервису CI/CD, например Jenkins, Buddy и т.д.

### SSH Ключи

Для передачи файлов на сервер необходимо настроить беспарольную аутентификацию, которая осуществляется с помощью SSH-ключей.

На вашем персональном компьютере необходимо выполнить следующие команды.

Перейдите в каталог с ключами SSH:

```sh
cd ~/.ssh
```

Сгенерируйте новую пару ключей:

::: code-group

```sh [GitHub]
ssh-keygen -t rsa -m PEM
```

```sh [GitLab]
ssh-keygen -t ed25519
```

:::

Эта команда сгенерирует открытый и закрытый ключ нужного вам типа и формата для GitHub и GitLab.
При желании вы можете указать собственное имя ключа.

Затем отправьте **публичный** ключ на сервер:

```sh
ssh-copy-id -i <имя-ключа>.pub root@<ip-адрес>
```

Замените `<имя-ключа>` на имя сгенерированного ключа, а `<ip-адрес>` на IP-адрес вашего сервера.

Обратите внимание, что **публичный** ключ может находиться на многих серверах, а **приватный** ключ должен быть только у вас и GitHub или GitLab.

Теперь вы можете подключиться к серверу без необходимости вводить пароль.

### Примеры Workflow

#### Node.js (GitHub)

Используйте

```yml
name: Main

on:
  push:
    branches:
      - main

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0
      - uses: actions/setup-node@v3
        with:
          node-version: "latest"
      - run: npm ci
      - name: Build
        run: npm run build
      - uses: actions/upload-artifact@v3
        with:
          name: source
          path: |
            dist/*.js
            package.json
            package-lock.json
  deploy:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/download-artifact@v3
        with:
          name: source
          path: dist/
      - name: Deploy
        uses: easingthemes/ssh-deploy@v4
        env:
          SOURCE: "dist package.json package-lock.json"
          ARGS: "--delete -az"
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          REMOTE_HOST: ${{ secrets.REMOTE_HOST }}
          REMOTE_USER: ${{ secrets.REMOTE_USER }}
          TARGET: "<директория-проекта>"
          SCRIPT_AFTER: |
            cd <директория-проекта>
            npm i --omit=dev
            <команда-для-запуска>
```

где `<директория-проекта>` заменяется именем директории, в которой на сервере хранится сборка бота, а `<команда-для-запуска>` --- командой для запуска бота, которая может быть, например, вызовом `pm2` или `systemctl`.

Этот скрипт последовательно выполняет две задачи: `build` и `deploy`.
После выполнения `build`, директория `dist`, содержащая сборку бота, передается задаче `deploy`.

Доставка файлов на сервер осуществляется с помощью утилиты `rsync`, которая реализована в `easingthemes/ssh-deploy`.
После того как файлы доставлены на сервер, выполняется команда, описанная в переменной окружения `SCRIPT_AFTER`.
В нашем случае после доставки файлов мы переходим в директорию бота, где устанавливаем все зависимости, кроме `devDependencies`, и перезапускаем бота.

Обратите внимание, что вам необходимо добавить три [секретные переменные окружения](https://docs.github.com/en/actions/how-tos/write-workflows/choose-what-workflows-do/use-secrets):

1. `SSH_PRIVATE_KEY` --- здесь должен храниться приватный SSH-ключ, который вы создали на [предыдущем шаге](#ssh-ключи).
2. `REMOTE_HOST` --- здесь должен храниться IP адрес вашего сервера.
3. `REMOTE_USER` --- здесь должно храниться имя пользователя, от имени которого запускается бот.

#### Node.js (GitLab)

Используйте

```yml
image: node:latest

stages:
  - build
  - deploy

Build:
  stage: build
  before_script: npm ci
  script: npm run build
  artifacts:
    paths:
      - dist/

Deploy:
  stage: deploy
  before_script:
    - "command -v ssh-agent >/dev/null || ( apt-get update -y && apt-get install openssh-client -y )"
    - "command -v rsync >/dev/null || ( apt-get update -y && apt-get install rsync -y )"
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan "$REMOTE_HOST" >> ~/.ssh/known_hosts
    - chmod 644 ~/.ssh/known_hosts
  script:
    - rsync --delete -az dist package.json package-lock.json $REMOTE_USER@$REMOTE_HOST:<директория-проекта>
    - ssh $REMOTE_USER@$REMOTE_HOST "cd <директория-проекта> && npm i --omit=dev && <команда-для-запуска>"
```

где `<директория-проекта>` заменяется именем директории, в которой на сервере хранится сборка бота, а `<команда-для-запуска>` --- командой для запуска бота, которая может быть, например, вызовом `pm2` или `systemctl`.

Этот скрипт последовательно выполняет две задачи: `build` и `deploy`.
После выполнения `build`, директория `dist`, содержащая сборку бота, передается задаче `deploy`.

Файлы доставляются на сервер с помощью утилиты `rsync`, которую мы должны установить перед выполнением основного скрипта.
После доставки файлов мы подключаемся к серверу по SSH, чтобы выполнить команду установки всех зависимостей, кроме `devDependencies`, и перезапустить приложение.

Обратите внимание, что вам необходимо добавить три [переменные окружения](https://docs.gitlab.com/ci/variables/):

1. `SSH_PRIVATE_KEY` --- здесь должен храниться приватный SSH-ключ, который вы создали на [предыдущем шаге](#ssh-ключи).
2. `REMOTE_HOST` --- здесь должен храниться IP адрес вашего сервера.
3. `REMOTE_USER` --- здесь должно храниться имя пользователя, от имени которого запускается бот.

#### Deno (GitHub)

Используйте

```yml
name: Main

on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0
      - name: Deploy
        uses: easingthemes/ssh-deploy@v4
        env:
          SOURCE: "src deno.jsonc deno.lock"
          ARGS: "--delete -az"
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          REMOTE_HOST: ${{ secrets.REMOTE_HOST }}
          REMOTE_USER: ${{ secrets.REMOTE_USER }}
          TARGET: "<директория-проекта>"
          SCRIPT_AFTER: |
            cd <директория-проекта>
            <команда-для-запуска>
```

где `<директория-проекта>` заменяется именем директории, в которой на сервере хранится сборка бота, а `<команда-для-запуска>` --- командой для запуска бота, которая может быть, например, вызовом `pm2` или `systemctl`.

Этот скрипт отправляет файлы на сервер с помощью утилиты `rsync`, которая реализована в `easingthemes/ssh-deploy`.
После того как файлы доставлены на сервер, выполняется команда, описанная в переменной окружения `SCRIPT_AFTER`.
В нашем случае после доставки файлов мы переходим в директорию бота и перезапускаем его.

Обратите внимание, что вам необходимо добавить три [секретные переменные окружения](https://docs.github.com/en/actions/how-tos/write-workflows/choose-what-workflows-do/use-secrets):

1. `SSH_PRIVATE_KEY` --- здесь должен храниться приватный SSH-ключ, который вы создали на [предыдущем шаге](#ssh-ключи).
2. `REMOTE_HOST` --- здесь должен храниться IP адрес вашего сервера.
3. `REMOTE_USER` --- здесь должно храниться имя пользователя, от имени которого запускается бот.

#### Deno (GitLab)

Используйте

```yml
image: denoland/deno:latest

stages:
  - deploy

Deploy:
  stage: deploy
  before_script:
    - "command -v ssh-agent >/dev/null || ( apt-get update -y && apt-get install openssh-client -y )"
    - "command -v rsync >/dev/null || ( apt-get update -y && apt-get install rsync -y )"
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan "$REMOTE_HOST" >> ~/.ssh/known_hosts
    - chmod 644 ~/.ssh/known_hosts
  script:
    - rsync --delete -az src deno.jsonc deno.lock $REMOTE_USER@$REMOTE_HOST:<директория-проекта>
    - ssh $REMOTE_USER@$REMOTE_HOST "cd <директория-проекта> && npm i --omit=dev && <команда-для-запуска>"
```

где `<директория-проекта>` заменяется именем директории, в которой на сервере хранится сборка бота, а `<команда-для-запуска>` --- командой для запуска бота, которая может быть, например, вызовом `pm2` или `systemctl`.

Этот скрипт отправляет файлы на сервер с помощью `rsync`, который должен быть предварительно установлен.
После того как файлы скопированы, мы подключаемся к серверу по SSH, чтобы перезапустить бота.

Обратите внимание, что вам необходимо добавить три [переменные окружения](https://docs.gitlab.com/ci/variables/):

1. `SSH_PRIVATE_KEY` --- здесь должен храниться приватный SSH-ключ, который вы создали на [предыдущем шаге](#ssh-ключи).
2. `REMOTE_HOST` --- здесь должен храниться IP адрес вашего сервера.
3. `REMOTE_USER` --- здесь должно храниться имя пользователя, от имени которого запускается бот.

Теперь вы должны видеть, как каждый код, добавленный в ветку `main`, будет автоматически разворачиваться на вашем VPS.
Разработка go brrrr :rocket:
